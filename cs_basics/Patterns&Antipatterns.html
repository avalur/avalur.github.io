<!doctype html>
<html lang="en">
	<head>
		<meta charset="utf-8">
		<meta name="apple-mobile-web-app-capable" content="yes" />
		<meta name="apple-mobile-web-app-status-bar-style" content="black-translucent" />
		<meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no, minimal-ui">

		<title>Programming Patterns and Anti-Patterns</title>

		<link rel="stylesheet" href="../dist/reset.css">
		<link rel="stylesheet" href="../dist/reveal.css">
		<link rel="stylesheet" href="../dist/theme/sky.css">

        <!-- Theme used for syntax highlighted code -->
		<link rel="stylesheet" href="../plugin/highlight/monokai.css">
		<link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/11.8.0/styles/default.min.css">

		<script src="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/11.8.0/highlight.min.js"></script>

		<!-- and it's easy to individually load additional languages -->
		<script src="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/11.8.0/languages/go.min.js"></script>

		<link rel="stylesheet" href="https://pyscript.net/latest/pyscript.css" />
		<script>
			import hljs from "highlight.js";

			hljs.highlightAll();
		</script>
		<style>
			.column {
			  float: left;
			  width: 48%;
			  padding: 2px;
			}
			/* Clear floats after image containers */
			.row::after {
			  content: "";
			  clear: both;
			  display: table;
			}
			.important {
				color: orange;
			}
			.hierarchy-box { padding: 10px; border-radius: 4px; text-align: center; }
			.parent { background-color: #aaa; }
			.child { background-color: #ccc; display: inline-block; margin: 5px; }
			.special { background-color: #f88; }
		</style>
</head>
	<body onload="totalWrapper();">
		<div class="reveal">
			<div class="slides">
			<section>
				<div>
					<img src="images/nup_logo_dark.jpeg" alt="nup_logo" />
				</div>
				<h2>Programming Paradigms</h2>
				<h3>Programming Patterns and Anti-Patterns</h3>
				<br />
				Alex Avdiushenko <br />
				May 15, 2025
			</section>
			<section>
				<section>
					<h3 style="text-align: left">Evolution of Design Patterns</h3>
						<div class="typesetting">
							<ul>
								<li class="fragment"><strong class="important">Early Days (Before 1990s):</strong>
									Reuse of code snippets and solutions without a standardized methodology</li>
								<li class="fragment"><strong class="important">The Gang of Four (1994):</strong>
									Formal introduction of design patterns by Erich Gamma, Richard Helm, Ralph Johnson,
									and John Vlissides. Their book laid the groundwork for object-oriented design patterns</li>
								<li class="fragment"><strong class="important">Pattern Languages (Late 1990s):</strong>
									The concept of pattern languages emerged, emphasizing the relationships
									between patterns within a system</li>
							</ul>
						</div>
				</section>
				<section>
					<ul>
						<li><strong class="important">
							Rise of Software Frameworks and Libraries (2000s):</strong>
							Frameworks and libraries encapsulated design patterns,
							making them more accessible and integral to software development</li>
						<li class="fragment"><strong class="important">
							Advent of Microservices and Cloud Computing (2010s):</strong>
							New patterns developed to address the complexities of distributed systems,
							focusing on scalability, resilience, and inter-service communication</li>
						<li class="fragment"><strong class="important">Current Trends and Future Directions:</strong>
							Design patterns evolve with advancements in AI (agents), machine learning,
							IoT, emphasizing adaptability, modularity,
							and interoperability for complex data flows and system integration</li>
					</ul>
				</section>
				<section data-background-color="white">
					<img src="images/airplane_blueprint.jpg" alt="airplane_blueprint" width="70%">
				</section>
				<section data-background-color="white">
					<img src="images/molds.jpg" alt="molds" width="70%">
				</section>
				<section>
					<h3 style="text-align: left">Real-world Analogy: Design Patterns</h3>
					<div class="fragment">
						<div class="typesetting">
							<p style="text-align: left">Design patterns in software are akin
								to templates used in construction and manufacturing industries.
								Î¤hey provide a standardized approach to solving common software design problems.
							</p>
						</div>
					</div>
					<div class="fragment">
						<div class="typesetting">
							<ul>
								<li><strong class="important">Construction Templates:</strong>
									In construction, <span class="important">templates and blueprints</span>
									guide the building process, ensuring that structures are built to specifications.
									Similarly, design patterns guide software architecture,
									ensuring that components work together seamlessly</li>
								<li><strong class="important">Manufacturing Molds:</strong>
									In manufacturing, <span class="important">molds</span>
									are used to produce items that are identical in shape and size,
									allowing for efficiency and uniformity.
									In software, design patterns ensure that code structures and algorithms
									are applied consistently, improving code quality and maintainability</li>
							</ul>
						</div>
					</div>
				</section>
				<section>
					<h3 style="text-align: left">Categories of Design Patterns</h3>
					<ul>
						<li class="fragment"><strong class="important">Creational Patterns:</strong>
							Focus on object creation mechanisms, streamlining the instantiation process.
							Examples include Singleton, Factory Method, Abstract Factory, Builder, and Prototype</li>
						<li class="fragment"><strong class="important">Structural Patterns:</strong>
							Deal with arranging objects and classes into larger structures,
							while maintaining flexibility and efficiency.
							Examples include Adapter, Composite, Proxy, Flyweight, Facade, Bridge, and Decorator</li>
						<li class="fragment"><strong class="important">Behavioral Patterns:</strong>
							Concerned with efficient communication and the assignment of responsibilities between objects.
							Examples include Strategy, Observer, Command, Iterator, State, Visitor, Template Method,
							Mediator, and Memento</li>
						<li class="fragment"><strong class="important">Concurrency Patterns:</strong>
							Address multi-threading issues and improve the performance of applications
							in concurrent environments. Examples include Producer-Consumer, Readers-Writers,
							and Dining Philosophers</li>
					</ul>
				</section>
				<section>
					<h3 style="text-align: left">Example Application of Patterns in Software Frameworks</h3>
					<div class="fragment">
						<div class="typesetting">
							<ul>
								<li><strong class="important">Singleton:</strong> Frameworks use it for managing configurations or connections
									(e.g., database connections in Spring)</li>
								<li><strong class="important">Observer:</strong> Widely used in GUI libraries
									(e.g., event listeners in JavaScript frameworks)</li>
								<li><strong class="important">Factory Method:</strong>
									Creation of objects without exposing the instantiation logic
									(e.g., document object creation in DOM)</li>
								<li><strong class="important">Adapter:</strong>
									Facilitates communication between modern frameworks and
									legacy systems or third-party libraries</li>
							</ul>
						<p style="text-align: left">These patterns are fundamental in developing robust, scalable, and maintainable software applications.
							<a href="https://www.youtube.com/watch?v=mE3qTp1TEbg&list=PLlsmxlJgn1HJpa28yHzkBmUY-Ty71ZUGc">Here is playlist</a>
							with detailed explanation of each pattern in Java,
							and <a href="https://github.com/avalur/avalur.github.io/tree/master/cs_basics/PatternPractice">here is</a>
							zip-archive with some pattern examples for practice in IDE.</p>
						</p>
						</div>
					</div>
				</section>
				<section>
					<h3 style="text-align: left">Singleton Pattern (Creational)</h3>
					<div class="fragment">
						<div class="typesetting">
							<p style="text-align: left">The Singleton pattern ensures that a class has
								only one instance and provides a global point of access to it.
								This pattern is useful for managing resources like database connections or configurations.</p>
						</div>
					</div>
					<div class="fragment">
						<div class="typesetting">
						<ul>
							<li><strong class="important">Implementation:</strong> Make the constructor private,
								create a static method that contains the instance logic,
								ensuring that only one instance is created and returned</li>
							<li><strong class="important">Use Cases:</strong> Logging, database connections,
								file managers where a single shared resource is preferable</li>
							<li><strong class="important">Pros and Cons:</strong>
								Easy implementation, but can introduce global state into an application,
								making it harder to test</li>
						</ul>
						</div>
					</div>
				</section>
				<section>
					<h3 style="text-align: left">Observer Pattern (Behavioral)</h3>
					<div class="fragment">
						<div class="typesetting">
						<p style="text-align: left">The Observer pattern defines a one-to-many
							dependency between objects so that when one object changes state,
							all its dependents are notified and updated automatically.</p>
						</div>
					</div>
					<div class="fragment">
						<div class="typesetting">
						<ul>
							<li><strong class="important">Implementation:</strong>
								It involves a subject (publisher) and observers (subscribers).
								The subject maintains a list of observers and notifies
								them of changes</li>
							<li><strong class="important">Use Cases:</strong> GUI tools,
								event management, reactive programming</li>
							<li><strong class="important">Benefits:</strong>
								Promotes loose coupling, enhancing flexibility and reuse</li>
						</ul>
						</div>
					</div>
				</section>
				<section>
					<h3 style="text-align: left">Factory Method Pattern (Creational)</h3>
					<div class="fragment">
						<div class="typesetting">
						<p style="text-align: left">The Factory Method Pattern provides an interface
							for creating objects in a superclass but allows subclasses
							to alter the type of objects that will be created.</p>
						</div>
					</div>
					<div class="fragment">
						<div class="typesetting">
							<ul>
								<li><strong class="important">Implementation:</strong>
									Define an interface for creating an object, but let subclasses decide which class to instantiate. The Factory Method lets a class defer instantiation to subclasses
								</li>
								<li><strong class="important">Use Case:</strong>
									Frameworks, toolkits where library code needs to create objects without knowing the specific types (classes)
								</li>
								<li><strong class="important">Advantages:</strong>
									Fosters code reusability and scalability; decouples object creation from its usage
								</li>
							</ul>
						</div>
					</div>
				</section>
				<section>
					<h3 style="text-align: left">Adapter Pattern (Structural)</h3>
					<div class="fragment">
						<div class="typesetting">
							<p style="text-align: left">The Adapter Pattern allows incompatible interfaces
							to work together. It acts as a bridge between two incompatible interfaces
							by wrapping itself around the object needing adaptation.</p>
						</div>
					</div>
					<div class="fragment">
						<div class="typesetting">
						<ul>
							<li><strong class="important">Implementation:</strong>
								Involves two classes: an "Adapter" that holds an instance
								of the "Adaptee" class. The adapter implements the target
								interface and translates calls to the adaptee's interface
							</li>
							<li><strong class="important">Use Cases:</strong>
								Integration of new features or libraries into existing applications, cross-platform systems
							</li>
							<li><strong class="important">Benefits:</strong>
								Increases compatibility between classes without changing their source code
							</li>
						</ul>
						</div>
					</div>
				</section>
			</section>
			<section>
				<section>
					<h3 style="text-align: left">Anti-Patterns: Recognizing and Avoiding Pitfalls</h3>
					<div class="fragment">
						<div class="typesetting">
						<ul>
							<li><strong class="important">Definition:</strong> An anti-pattern may be commonly used
								but is ineffective and/or counterproductive in practice</li>
							<li><strong  class="important">Impact:</strong> Leads to negative consequences,
								making software harder to maintain, less efficient, and more complex</li>
						</ul>
						</div>
					</div>
				</section>
				<section>
					<h3 style="text-align: left">Common Anti-Patterns</h3>
					<div class="fragment">
						<h4>Code-Level Antipatterns</h4>
						<ul>
							<li><strong class="important">God Object:</strong> Concentrating too many functions in a single part of the design (class)</li>
							<li><strong class="important">Spaghetti Code:</strong> Code with a complex and tangled control structure</li>
						</ul>
					</div>
					<div class="fragment">
						<br>
						<h4>Architectural Antipatterns</h4>
						<ul>
							<li><strong class="important">Golden Hammer:</strong>
								Over-reliance on a familiar tool or concept, ignoring more suitable approaches
							</li>
							<li><strong class="important">Vendor Lock-in:</strong>
								Becoming too dependent on a vendor's technologies, making it difficult to switch to another vendor without substantial costs and changes
							</li>
							<li><strong class="important">Lava Flow:</strong>
								Retaining needless code because of uncertainty about its usage, leading to clutter and complexity
							</li>
						</ul>
					</div>
				</section>
				<section>
					<h4>Project Management Antipatterns</h4>
					<ul>
						<li><strong class="important">Adding manpower to a late software project:</strong>
							Often makes it later due to the ramp-up time needed for new team members
						</li>
						<li><strong class="important">Silver Bullet:</strong>
							Belief that a new technology, tool, or practice will solve all problems
						</li>
					</ul>
					<img class="fragment" src="images/anti-pattern-meme.png" alt="anti-pattern-meme" width="40%">
				</section>
				<section>
					<h3 style="text-align: left">Strategies to Identify and Refactor Anti-Patterns</h3>
					<div class="fragment">
						<div class="typesetting">
						<p style="text-align: left">Identifying and addressing anti-patterns is crucial
							for maintaining healthy software architecture and project management practices.</p>
						<ul>
							<li><strong class="important">Code Reviews:</strong> Regularly review code with peers to identify complex,
								tightly coupled, or otherwise problematic code early</li>
							<li><strong class="important">Refactoring:</strong> Systematically improving code or design
								without altering its functionality, to remove anti-patterns and improve maintainability</li>
							<li><strong class="important">Adopting Best Practices:</strong>
								Stay informed about and adhere to industry best practices for coding, design, and project management</li>
							<li><strong class="important">Continuous Learning:</strong>
								Encourage a culture of learning and adaptation,
								embracing new and more effective patterns and technologies</li>
						</ul>
						</div>
					</div>
				</section>
				<section>
					<h3 style="text-align: left">Real cases: Design Patterns in Action</h3>
					<div class="fragment">
						<div class="typesetting">
							<p style="text-align: left"><a href="https://en.wikipedia.org/wiki/Real_Programmers_Don%27t_Use_Pascal">
								Real Programmers Don't Use Pascal</a>, 1982</p>
							<ul>
								<li>Real Programmers do List Processing in FORTRAN.</li>
								<li>Real Programmers do String Manipulation in FORTRAN.</li>
								<li>Real Programmers do Accounting (if they do it at all) in FORTRAN.</li>
								<li>Real Programmers do Artificial Intelligence programs in FORTRAN.</li>
							</ul>
						</div>
					</div>
				</section>
				<section>
					<img src="images/fortran_modules.png" alt="fortran_modules">
				</section>
				<section>
					<h3 style="text-align: left">Fortran Code Example from past century</h3>
					<pre><code class="language-fortran">
      SUBROUTINE ASVOPD(RES,IPR,H1,H2,H3,H,*,NNN)
C*****PAÐÐOÐEHÐE BEKTOPA OTHOCÐTEÐÐ¬HO PEÐEPA
C*****BEPCÐÐ¯: 08 (05.01.99)
      DIMENSION RES(3),H1(3),H2(3),H3(3),H(3)
      DIMENSION IYY(3),IWW(11)
      REAL*8 ROP,R,A
      INTEGER*2 INU(28)
      COMMON IRAS/VOP/ROP(36)
      SAVE
      DATA IYY/0,'ASVO','PD09'/
      DATA IWW/'ÐÐÐ Ð','ÐÐÐ¢ ','ÐÐ 1','-3  ','****',
     *         'BÐ«PO','ÐÐEH','HÐ«Ð ','PEÐE','P   ','****'/
      DATA INU/2,1,1,1404,405,2000,0,
     *        4,1,1,1,1,1001,506,1002,604,1003,405,-108,207,-109,307,
     *        -107,107,-101,104,2000,0/
      DATA Y/7777777777./
      CALL ATRASW(0,IYY)
      SELECT CASE(IPR)
      CASE(1,2)
C.....ÑÐ°Ð·Ð»Ð¾Ð¶ÐµÐ½Ð¸Ðµ Ð¿Ð¾ ÑÐµÐ¿ÐµÑÑ
         IF(IPR.EQ.2) CALL ASVOPM(H3,INU,H1,H2,Y,Y,Y,Y,Y,Y,*100,1)
         CALL ASVOPM(RES,INU(8),H1,H2,H3,H,Y,Y,Y,Y,*100,2)
         R=ROP(1)
         DO I=1,3
            A=ROP(I+6)
            IF(R.EQ.0.OR.DABS(A)*1E-20.GT.DABS(R)) GOTO 102
            RES(I)=A/R
         ENDDO
      CASE(3)
C.....Ð»Ð¸Ð½ÐµÐ¹Ð½Ð°Ñ ÐºÐ¾Ð¼Ð±Ð¸Ð½Ð°ÑÐ¸Ñ Ð²ÐµÐºÑÐ¾ÑÐ¾Ð² ÑÐµÐ¿ÐµÑÐ°
         DO I=1,3
            RES(I)=H(1)*H1(I)+H(2)*H2(I)+H(3)*H3(I)
         ENDDO
C.....Ð¾ÑÐ¸Ð±Ð¾ÑÐ½Ð¾Ðµ Ð·Ð½Ð°ÑÐµÐ½Ð¸Ðµ IPR
      CASE DEFAULT
         GOTO 101
      ENDSELECT
      RETURN
C.....Ð¾Ð±ÑÐ°Ð±Ð¾ÑÐºÐ° Ð°Ð²Ð°ÑÐ¸Ð¹Ð½ÑÑ ÑÐ¸ÑÑÐ°ÑÐ¸Ð¹
  102 IRAS=IRAS+1
  101 IRAS=IRAS+1
  100 CALL ATRAS(IYY(2),IWW,NNN)
      RETURN 1
      END
					</code></pre>
				</section>
				<section>
					<h3 style="text-align: left">Fortran Code Example from our century</h3>
					<pre><code class="language-fortran">
c    Ð ÑÑÐ¾Ð¼ ÑÐ°Ð¹Ð»Ðµ ÑÐ¾Ð´ÐµÑÐ¶Ð¸ÑÑÑ Ð¿ÑÐ¾ÑÐµÐ´ÑÑÐ° Solve_ke_equations Ð´Ð»Ñ
c    ÑÐ°ÑÑÐµÑÐ° ÑÑÐ°Ð²Ð½ÐµÐ½Ð¸Ð¹ Ð½Ð° ÑÐ°ÑÐ°ÐºÑÐµÑÐ¸ÑÑÐ¸ÐºÐ¸ ÑÑÑÐ±ÑÐ»ÐµÐ½ÑÐ½Ð¾ÑÑÐ¸ k Ð¸ eps,
c    Ð° ÑÐ°ÐºÐ¶Ðµ Ð²ÑÐ¿Ð¾Ð¼Ð¾Ð³Ð°ÑÐµÐ»ÑÐ½ÑÐµ Ð¿ÑÐ¾ÑÐµÐ´ÑÑÑ CF_IN, CF_VIS, Find_Ge_wall Ð¸ Find_eps_nw.
c    Ð ÐµÐ°Ð»Ð¸Ð·Ð¾Ð²Ð°Ð½Ð° ÑÑÐ°Ð½Ð´Ð°ÑÑÐ½Ð°Ñ k-e Ð¼Ð¾Ð´ÐµÐ»Ñ ÑÑÑÐ±ÑÐ»ÐµÐ½ÑÐ½Ð¾ÑÑÐ¸.

      SUBROUTINE Solve_ke_equations(K1,K2,K3,TLOC,
     *                 QP,SIX,SIY,SIZ,SJX,SJY,SJZ,SKX,SKY,SKZ,V,
     *                 X,Y,Z,KRT1,KRT2,YPI,YPJ,YPK,TK,TE,ResMK,ResME,
     *                 ResKMax,ResEMax,INTPAR,REALPAR,
     *                 BLOCK_SYMBOL,TurbineType,IsPrint,NDOMN,IError)

      USE OUTMOD
      IMPLICIT REAL*8 (A-H,O-Z)
      INCLUDE 'EXY'
      INTEGER SourceType,SumJK,SumIJK
      REAL*8 nu_wall
      CHARACTER*1 BLOCK_SYMBOL,TurbineType
      LOGICAL IsPrint,ReturnFlag
C     ÐÐ±ÑÑÐ²Ð»ÐµÐ½Ð¸Ðµ Ð²Ð½ÐµÑÐ½Ð¸Ñ Ð¼Ð°ÑÑÐ¸Ð²Ð¾Ð²
      DIMENSION QP(KM,KA11,KA21,KA31), V(KA11,KA21,KA31),
     *SIX(KA1,KA21,KA31),SIY(KA1,KA21,KA31),SIZ(KA1,KA21,KA31),
     *SJX(KA11,KA2,KA31),SJY(KA11,KA2,KA31),SJZ(KA11,KA2,KA31),
     *SKX(KA11,KA21,KA3),SKY(KA11,KA21,KA3),SKZ(KA11,KA21,KA3),
     *X(KA11,KA21,KA31),Y(KA11,KA21,KA31),Z(KA11,KA21,KA31),
     *KRT1(KA11,KA21,3),KRT2(KA11,KA21,3),
     *YPI(2,KA21,KA31),YPJ(2,KA11,KA31),YPK(2,KA11,KA21),
     *TK(KA11,KA21,KA31),TE(KA11,KA21,KA31),
     *ResMK(KA11,KA21,KA31),ResME(KA11,KA21,KA31),
     *INTPAR(50),REALPAR(50),
     *TLOC(KA11,KA21,KA31)


C     ÐÐ±ÑÑÐ²Ð»ÐµÐ½Ð¸Ðµ Ð²Ð½ÑÑÑÐµÐ½Ð½Ð¸Ñ Ð¼Ð°ÑÑÐ¸Ð²Ð¾Ð²
      DIMENSION
     *  PSYmK(KA11,KA21,KA31),dPsiK(KA11,KA21,KA31),
     *  PSYmE(KA11,KA21,KA31),dPsiE(KA11,KA21,KA31),
     *  RHSK(KA11,KA21,KA31),RHSE(KA11,KA21,KA31),
     *  VEI(KA1,KA21,KA31),VEJ(KA11,KA2,KA31),VEK(KA11,KA21,KA3),
     *  Qc(KM),Qir(KM),Qif(KM),Qjr(KM),Qjf(KM),Qkr(KM),Qkf(KM),
     *  FNKjr(KA11),FVKjr(KA11),FNEjr(KA11),FVEjr(KA11),
     *  DKM(KA11,KA21,KA31),CifKM(KA11,KA21,KA31),CjfKM(KA11,KA21,KA31),
     *  CkfKM(KA11,KA21,KA31),CirKM(KA11,KA21,KA31),
     *  CjrKM(KA11,KA21,KA31),CkrKM(KA11,KA21,KA31),
     *  DEM(KA11,KA21,KA31),CifEM(KA11,KA21,KA31),CjfEM(KA11,KA21,KA31),
     *  CkfEM(KA11,KA21,KA31),CirEM(KA11,KA21,KA31),
     *  CjrEM(KA11,KA21,KA31),CkrEM(KA11,KA21,KA31),
     *  SI(3),SJ(3),SK(3),QcM(KM),TKLoc(27),TELoc(27),KSDV(6,3)

      COMMON /turb/ Cmu,Ceps1,Ceps2,SigmaK,SigmaE,Ckar,CE,Ceps3

      K11=K1-1
      K21=K2-1
      K31=K3-1
      K12=K11-1
      K22=K21-1
      K32=K31-1
      K13=K12-1
      K23=K22-1
      K33=K32-1
      K14=K13-1
      K24=K23-1
      K34=K33-1
      K15=K14-1

      ITN1 = INTPAR(4)
      ITN2 = INTPAR(5)
      IZNAK= INTPAR(11)
      OM   = REALPAR(8)
      Reyn = REALPAR(13)
      Rsrez= REALPAR(16)

      nz_begin= INTPAR(33)
      nz_end  = INTPAR(34)

      vlam=1.d0/Reyn
      Kvis=1
      VeryLargeNumber=10.e+30
      ReturnFlag = .false.

cc==== Turbulence model parameters =====
c      Cmu   =0.09d0
c      Ceps1 =1.44d0
c      Ceps2 =1.92d0
c      SigmaK=1.0d0
c      SigmaE=1.3d0
c      Ckar  =0.4d0
c      CE    =9.0d0
cc======================================

!$omp parallel default(none)
!$omp& shared(QP,TK,TE,VEI,VEJ,VEK,PSYmK,PSYmE,TLOC,V,X,Y,Z)
!$omp& shared(SIX,SIY,SIZ,SJX,SJY,SJZ,SKX,SKY,SKZ,INTPAR,REALPAR)
!$omp& shared(YPI,YPJ,YPK,KRT1,KRT2)
!$omp& shared(RHSK,RHSE,ResMK,ResME)
!$omp& shared(CirKM,CjrKM,CkrKM,CifKM,CjfKM,CkfKM)
!$omp& shared(CirEM,CjrEM,CkrEM,CifEM,CjfEM,CkfEM)
!$omp& shared(DKM,DEM,dPsiK,dPsiE)
!$omp& private(vlam,tke_c,tke_ir,tke_jr,tke_kr)
!$omp& private(Qc,Qir,Qjr,Qkr,Qif,Qjf,Qkf,TAU)
!$omp& private(TKc,TKir,TKjr,TKkr,TKif,TKjf,TKkf)
!$omp& private(TEc,TEir,TEjr,TEkr,TEif,TEjf,TEkf)
!$omp& private(TK_mm,TE_mm,I_mm,J_mm,K_mm,IError,IWarn)
!$omp& private(SIXr,SIYr,SIZr,SJXr,SJYr,SJZr,SKXr,SKYr,SKZr)
!$omp& private(SIXf,SIYf,SIZf,SJXf,SJYf,SJZf,SKXf,SKYf,SKZf)
!$omp& private(Air,Apir,Amir,Ajr,Apjr,Amjr,Akr,Apkr,Amkr)
!$omp& private(Aif,Apif,Amif,Ajf,Apjf,Amjf,Akf,Apkf,Amkf)
!$omp& private(Volc,Volir,Voljr,Volkr,Volif,Voljf,Volkf)
!$omp& private(vKir,vKjr,vKkr,vKif,vKjf,vKkf)
!$omp& private(vEir,vEjr,vEkr,vEif,vEjf,vEkf)
!$omp& private(SSVir,SSVjr,SSVkr,SSVif,SSVjf,SSVkf)
!$omp& private(BirK,BjrK,BkrK,BifK,BjfK,BkfK)
!$omp& private(BirE,BjrE,BkrE,BifE,BjfE,BkfE)
!$omp& private(CirK,CjrK,CkrK,CifK,CjfK,CkfK)
!$omp& private(CirE,CjrE,CkrE,CifE,CjfE,CkfE)
!$omp& private(XX,YY,RR,isKcorner,DK,DE)
!$omp& private(FK0,FNKir,FNKjr,FNKkr,FNKif,FNKjf,FNKkf)
!$omp& private(FE0,FNEir,FNEjr,FNEkr,FNEif,FNEjf,FNEkf)
!$omp& private(IMM,IPP,KMM,KPP,JMM,JPP,Inn,Jnn,Knn)
!$omp& private(SI,SJ,SK)
!$omp& private(FVKir,FVKjr,FVKkr,FVKif,FVKjf,FVKkf)
!$omp& private(FVEir,FVEjr,FVEkr,FVEif,FVEjf,FVEkf)
!$omp& private(ddj,ddk,Q1K,Q2K,Q3K,Q1E,Q2E,Q3E)
!$omp& private(uim,ujm,ukm,vim,vjm,vkm,wim,wjm,wkm)
!$omp& private(uip,ujp,ukp,vip,vjp,vkp,wip,wjp,wkp)
!$omp& private(ux,uy,uz,vx,vy,vz,wx,wy,wz)
!$omp& private(vt,gg,Smod,GG_K,eps,eps1,SrcK,SrcE,HK,HE,eps_nw)
!$omp& private(VolEff,isIwall,isJwall,isKwall,SourceType)
!$omp& private(Krot,Xw,Yw,Zw,IP,QcM,ResK,ResE)
!$omp& private(NKnegCorr,NEnegCorr,NEcutCorr,KSDV)
!$omp& private(TKsum,MP,is,ks,js,TELoc,TEmin,TEmedium,TEcut)
!$omp& private(vtc,vtir,vtif,vtjr,vtjf,vtkr,vtkf,vtmax)
!$omp& firstprivate(ReturnFlag,IZNAK,Reyn,NDOMN,nz_begin)
!$omp& firstprivate(Cmu,SigmaK,SigmaE,Ceps1,Ceps2,Ceps3)
!$omp& firstprivate(BLOCK_SYMBOL,OM,Ckar,CE,TurbineType,Rsrez)
!$omp& firstprivate(VeryLargeNumber)
!$omp& firstprivate(K1,K2,K3,K11,K21,K31,K12,K22,K32,K13,K23,K33)
!$omp& reduction(max: ResKMax, ResEMax)
!$omp& reduction(+: SumDivK, SumDivE, SumVol)

!$omp do
      DO 120 k=3,K32
      DO 120 j=3,K22
      DO 120 i=3,K12
        tke_c =(TK(i,j,k  )**2)/TE(i,j,k)
        tke_ir=(TK(i-1,j,k)**2)/TE(i-1,j,k)
        tke_jr=(TK(i,j-1,k)**2)/TE(i,j-1,k)
        tke_kr=(TK(i,j,k-1)**2)/TE(i,j,k-1)
        VEI(i,j,k) = vlam+0.5d0*Cmu*(tke_c+tke_ir)
        VEJ(i,j,k) = vlam+0.5d0*Cmu*(tke_c+tke_jr)
        VEK(i,j,k) = vlam+0.5d0*Cmu*(tke_c+tke_kr)
120   CONTINUE

      ResKMax= 0.d0
      ResEMax= 0.d0
      SumDivK= 0.d0
      SumDivE= 0.d0
      SumVol = 0.d0

C***** Boundary conditions for PSYmK and PSYmE ***********
!$omp do
      DO 370 j=3,K23
      DO 370 i=3,K13
          PSYmK(i,j,2)=0.d0
370       PSYmE(i,j,2)=0.d0
!$omp do
      DO 380 k=3,K33
      DO 380 j=3,K23
          PSYmK(2,j,k)=0.d0
380       PSYmE(2,j,k)=0.d0
!$omp do
      DO 390 k=3,K33
      DO 390 i=3,K13
          PSYmK(i,2,k)=0.d0
390       PSYmE(i,2,k)=0.d0

c      write(*,*)(' UP - started')

c=================================================================
C******* Ð ÐÐ¡Ð§ÐÐ¢ ÐÐÐÐ¯ÐÐÐ RHS ÐÐ ÐÐ¡ÐÐ ÐÐÐÐÐ¡Ð¢Ð ********************
!$omp do
      DO 560 k=3,K33
      DO 560 j=3,K23
      DO 560 i=3,K13
c       write(*,*)i,j,k

C******* Block of calculation nearest Q, TK, TE ******************
       DO 405 m=1,4
         Qc (m)=QP(m,i,j,k)
         Qir(m)=QP(m,i-1,j,k)
         Qjr(m)=QP(m,i,j-1,k)
         Qkr(m)=QP(m,i,j,k-1)
         Qif(m)=QP(m,i+1,j,k)
         Qjf(m)=QP(m,i,j+1,k)
         Qkf(m)=QP(m,i,j,k+1)
405    CONTINUE

       TAU=TLOC(i,j,k)

       TKc =TK(i,j,k)
       TKir=TK(i-1,j,k)
       TKjr=TK(i,j-1,k)
       TKkr=TK(i,j,k-1)
       TKif=TK(i+1,j,k)
       TKjf=TK(i,j+1,k)
       TKkf=TK(i,j,k+1)

       TEc =TE(i,j,k)
       TEir=TE(i-1,j,k)
       TEjr=TE(i,j-1,k)
       TEkr=TE(i,j,k-1)
       TEif=TE(i+1,j,k)
       TEjf=TE(i,j+1,k)
       TEkf=TE(i,j,k+1)

       if(TKc.LT.1.e-16) then
         TK_mm=TKc
         I_mm=i
         J_mm=j
         K_mm=k
C        ÐÑÐ´Ð°ÐµÐ¼ Ð¾ÑÐ¸Ð±ÐºÑ: TK <= 0.
         CALL OUTER(123,'E',IError,IWarn)
         if(IError.NE.0) ReturnFlag = .true.
       endif
       if(TEc.LT.1.e-16) then
         TE_mm=TEc
         I_mm=i
         J_mm=j
         K_mm=k
C        ÐÑÐ´Ð°ÐµÐ¼ Ð¾ÑÐ¸Ð±ÐºÑ: TE <= 0.
         CALL OUTER(124,'E',IError,IWarn)
         if(IError.NE.0) ReturnFlag = .true.
       endif

       SIXr=SIX(i,j,k)
       SIYr=SIY(i,j,k)
       SIZr=SIZ(i,j,k)
       SJXr=SJX(i,j,k)
       SJYr=SJY(i,j,k)
       SJZr=SJZ(i,j,k)
       SKXr=SKX(i,j,k)
       SKYr=SKY(i,j,k)
       SKZr=SKZ(i,j,k)
       SIXf=SIX(i+1,j,k)
       SIYf=SIY(i+1,j,k)
       SIZf=SIZ(i+1,j,k)
       SJXf=SJX(i,j+1,k)
       SJYf=SJY(i,j+1,k)
       SJZf=SJZ(i,j+1,k)
       SKXf=SKX(i,j,k+1)
       SKYf=SKY(i,j,k+1)
       SKZf=SKZ(i,j,k+1)
c      write(*,*)('Nearest TK,TE -DONE')

C***** A-scalars ******************************************
C***** A-scalars are the Jacobians of inviscid fluxes *****
       Air=0.5d0*((Qir(2)+Qc(2))*SIXr+
     *            (Qir(3)+Qc(3))*SIYr+
     *            (Qir(4)+Qc(4))*SIZr)
       Apir=0.5d0*(Air+DABS(Air))

       Ajr=0.5d0*((Qjr(2)+Qc(2))*SJXr+
     *            (Qjr(3)+Qc(3))*SJYr+
     *            (Qjr(4)+Qc(4))*SJZr)
       Apjr=0.5d0*(Ajr+DABS(Ajr))

       Akr=0.5d0*((Qkr(2)+Qc(2))*SKXr+
     *            (Qkr(3)+Qc(3))*SKYr+
     *            (Qkr(4)+Qc(4))*SKZr)
       Apkr=0.5d0*(Akr+DABS(Akr))

       Aif=0.5d0*((Qc(2)+Qif(2))*SIXf+
     *            (Qc(3)+Qif(3))*SIYf+
     *            (Qc(4)+Qif(4))*SIZf)
       Amif=0.5d0*(Aif-DABS(Aif))

       Ajf=0.5d0*((Qc(2)+Qjf(2))*SJXf+
     *            (Qc(3)+Qjf(3))*SJYf+
     *            (Qc(4)+Qjf(4))*SJZf)
       Amjf=0.5d0*(Ajf-DABS(Ajf))

       Akf=0.5d0*((Qc(2)+Qkf(2))*SKXf+
     *            (Qc(3)+Qkf(3))*SKYf+
     *            (Qc(4)+Qkf(4))*SKZf)
       Amkf=0.5d0*(Akf-DABS(Akf))

c      write(*,*)('A -DONE')

C***** B-scalars ******************************************
C***** B-scalars are the Jacobians of viscous fluxes ******
       Volc=V(i,j,k)
       Volir=0.5d0*(Volc+V(i-1,j,k))
       Volif=0.5d0*(Volc+V(i+1,j,k))
       Voljr=0.5d0*(Volc+V(i,j-1,k))
       Voljf=0.5d0*(Volc+V(i,j+1,k))
       Volkr=0.5d0*(Volc+V(i,j,k-1))
       Volkf=0.5d0*(Volc+V(i,j,k+1))

       vKir=vlam+(VEI(i,j,k)-vlam)/SigmaK
       vKjr=vlam+(VEJ(i,j,k)-vlam)/SigmaK
       vKkr=vlam+(VEK(i,j,k)-vlam)/SigmaK
       vKif=vlam+(VEI(i+1,j,k)-vlam)/SigmaK
       vKjf=vlam+(VEJ(i,j+1,k)-vlam)/SigmaK
       vKkf=vlam+(VEK(i,j,k+1)-vlam)/SigmaK
       vEir=vlam+(VEI(i,j,k)-vlam)/SigmaE
       vEjr=vlam+(VEJ(i,j,k)-vlam)/SigmaE
       vEkr=vlam+(VEK(i,j,k)-vlam)/SigmaE
       vEif=vlam+(VEI(i+1,j,k)-vlam)/SigmaE
       vEjf=vlam+(VEJ(i,j+1,k)-vlam)/SigmaE
       vEkf=vlam+(VEK(i,j,k+1)-vlam)/SigmaE

C      ÐÐ¾ÑÑÐµÐºÑÐ¸Ñ Ð²ÑÐ·ÐºÐ¾ÑÑÐµÐ¹ vK Ð¸ vE Ð² ÑÑÐµÐ¹ÐºÐ°Ñ, Ð¿ÑÐ¸Ð»ÐµÐ³Ð°ÑÑÐ¸Ñ Ðº ÑÐ²ÐµÑÐ´ÑÐ¼ ÑÑÐµÐ½ÐºÐ°Ð¼
       if((i.EQ.3).AND.(IZNAK.EQ.1)) then
         vKir=vlam+VEI(i,j,k)/SigmaK
         vEir=vlam+VEI(i,j,k)/SigmaE
       endif

       if(j.eq.3) then
         vKjr=vlam+VEJ(i,j,k)/SigmaK
         vEjr=vlam+VEJ(i,j,k)/SigmaE
       endif

       XX=0.5d0*(X(I,J,K)+X(I,J+1,K))
       YY=0.5d0*(Y(I,J,K)+Y(I,J+1,K))
       RR=DSQRT(XX**2+YY**2)
       if((J.eq.K23).and.
     *   ((BLOCK_SYMBOL.ne.'k').or.(RR.ge.Rsrez))) then
         vKjf=vlam+VEJ(i,j+1,k)/SigmaK
         vEjf=vlam+VEJ(i,j+1,k)/SigmaE
       endif
       if((k.eq.3).and.(KRT2(i,j,1).eq.1)) then
         vKkr=vlam+VEK(i,j,k)/SigmaK
         vEkr=vlam+VEK(i,j,k)/SigmaE
       endif
       if((k.eq.K33).and.(KRT1(i,j,1).eq.1)) then
         vKkf=vlam+VEK(i,j,k+1)/SigmaK
         vEkf=vlam+VEK(i,j,k+1)/SigmaE
       endif

       SSVir=(SIXr**2+SIYr**2+SIZr**2)/Volir
       SSVjr=(SJXr**2+SJYr**2+SJZr**2)/Voljr
       SSVkr=(SKXr**2+SKYr**2+SKZr**2)/Volkr
       SSVif=(SIXf**2+SIYf**2+SIZf**2)/Volif
       SSVjf=(SJXf**2+SJYf**2+SJZf**2)/Voljf
       SSVkf=(SKXf**2+SKYf**2+SKZf**2)/Volkf

       BirK= -vKir*SSVir
       BjrK= -vKjr*SSVjr
       BkrK= -vKkr*SSVkr
       BifK= -vKif*SSVif
       BjfK= -vKjf*SSVjf
       BkfK= -vKkf*SSVkf

       BirE= -vEir*SSVir
       BjrE= -vEjr*SSVjr
       BkrE= -vEkr*SSVkr
       BifE= -vEif*SSVif
       BjfE= -vEjf*SSVjf
       BkfE= -vEkf*SSVkf
c       write(*,*)('B -DONE')

C***** ÐÐ«Ð§ÐÐ¡ÐÐÐÐÐ ÐÐÐÐ¯ÐÐÐÐ¥ ÐÐÐ¢ÐÐÐÐ ÐÐÐ¯ Ð Ð¸ E-Ð£Ð ÐÐÐÐÐÐÐ *****************

C===== ÐÑÐ°Ð½Ñ i+1/2 ===================================================
       CALL CF_IN(Qc,Qif,TKc,TKif,SIXf,SIYf,SIZf,FNKif)
       CALL CF_IN(Qc,Qif,TEc,TEif,SIXf,SIYf,SIZf,FNEif)
C      write(*,*)(' FNKif')

C===== ÐÑÐ°Ð½Ñ j+1/2 ===================================================
       CALL CF_IN(Qc,Qjf,TKc,TKjf,SJXf,SJYf,SJZf,FNKjf)
       CALL CF_IN(Qc,Qjf,TEc,TEjf,SJXf,SJYf,SJZf,FNEjf)
C      write(*,*)(' FNKjf')

C===== ÐÑÐ°Ð½Ñ k+1/2 ===================================================
       CALL CF_IN(Qc,Qkf,TKc,TKkf,SKXf,SKYf,SKZf,FNKkf)
       CALL CF_IN(Qc,Qkf,TEc,TEkf,SKXf,SKYf,SKZf,FNEkf)
C      write(*,*)(' FNKkf')

C===== ÐÑÐ°Ð½Ñ i-1/2 ===================================================
       if(i.EQ.3) then
         CALL CF_IN(Qir,Qc,TKir,TKc,SIXr,SIYr,SIZr,FNKir)
         CALL CF_IN(Qir,Qc,TEir,TEc,SIXr,SIYr,SIZr,FNEir)
C        write(*,*)(' FNKir')
       endif

C===== ÐÑÐ°Ð½Ñ j-1/2 ===================================================
       if(j.EQ.3) then
         CALL CF_IN(Qjr,Qc,TKjr,TKc,SJXr,SJYr,SJZr,FK0)
         CALL CF_IN(Qjr,Qc,TEjr,TEc,SJXr,SJYr,SJZr,FE0)
C        write(*,*)(' FNKjr')
         FNKjr(i)=FK0
         FNEjr(i)=FE0
       endif

C===== ÐÑÐ°Ð½Ñ k-1/2 ===================================================
c       if(k.EQ.3) then
         CALL CF_IN(Qkr,Qc,TKkr,TKc,SKXr,SKYr,SKZr,FK0)
         CALL CF_IN(Qkr,Qc,TEkr,TEc,SKXr,SKYr,SKZr,FE0)
C        write(*,*)(' FNKkr')
         FNKkr=FK0
         FNEkr=FE0
c       endif

c       write(*,*)('FN -DONE')

C***********************************************************************
C     ÐÐ«Ð§ÐÐ¡ÐÐÐÐÐ ÐÐ¯ÐÐÐÐ¥ ÐÐÐ¢ÐÐÐÐ

C======ÐÐ¯ÐÐÐÐ ÐÐÐ¢ÐÐ Ð§ÐÐ ÐÐ ÐÐ ÐÐÐ¬ i+1/2=========================
       jmm=j-1
       jpp=j+1
       kmm=k-1
       kpp=k+1
       ddj=0.25d0
       ddk=0.25d0
       if(k.eq.3)   then
          kmm=k
          ddk=0.5d0
       endif
       if(k.eq.K33) then
          kpp=k
          ddk=0.5d0
       endif
       Q1K= TKif-TKc
       Q2K=ddj*(TK(i  ,jpp,k)-TK(i  ,jmm,k)+
     *          TK(i+1,jpp,k)-TK(i+1,jmm,k))
       Q3K=ddk*(TK(i  ,j,kpp)-TK(i  ,j,kmm)+
     *          TK(i+1,j,kpp)-TK(i+1,j,kmm))
C      --------------------------------------
       Q1E= TEif-TEc
       Q2E=ddj*(TE(i  ,jpp,k)-TE(i  ,jmm,k)+
     *          TE(i+1,jpp,k)-TE(i+1,jmm,k))
       Q3E=ddk*(TE(i  ,j,kpp)-TE(i  ,j,kmm)+
     *          TE(i+1,j,kpp)-TE(i+1,j,kmm))
      SI(1)=SIXf
      SI(2)=SIYf
      SI(3)=SIZf
      SJ(1)=(SJX(i,j+1,k)+SJX(i+1,j+1,k)+SJX(i,j,k)+SJX(i+1,j,k))/4.d0
      SJ(2)=(SJY(i,j+1,k)+SJY(i+1,j+1,k)+SJY(i,j,k)+SJY(i+1,j,k))/4.d0
      SJ(3)=(SJZ(i,j+1,k)+SJZ(i+1,j+1,k)+SJZ(i,j,k)+SJZ(i+1,j,k))/4.d0
      SK(1)=(SKX(i,j,k+1)+SKX(i+1,j,k+1)+SKX(i,j,k)+SKX(i+1,j,k))/4.d0
      SK(2)=(SKY(i,j,k+1)+SKY(i+1,j,k+1)+SKY(i,j,k)+SKY(i+1,j,k))/4.d0
      SK(3)=(SKZ(i,j,k+1)+SKZ(i+1,j,k+1)+SKZ(i,j,k)+SKZ(i+1,j,k))/4.d0
      CALL CF_VIS(Q1K,Q2K,Q3K,SI,SJ,SK,Volif,SI,vKif,FVKif)
      CALL CF_VIS(Q1E,Q2E,Q3E,SI,SJ,SK,Volif,SI,vEif,FVEif)

C======ÐÐ¯ÐÐÐÐ ÐÐÐ¢ÐÐ Ð§ÐÐ ÐÐ ÐÐ ÐÐÐ¬ j+1/2=========================
       Q1K=(TK(i+1,j,k)  -TK(i-1,j,k)+
     *      TK(i+1,j+1,k)-TK(i-1,j+1,k))/4.d0
       Q2K= TKjf-TKc
       Q3K=(TK(i,j,k+1)  -TK(i,j,k-1)+
     *      TK(i,j+1,k+1)-TK(i,j+1,k-1))/4.d0
C      --------------------------------------
       Q1E=(TE(i+1,j,k)  -TE(i-1,j,k)+
     *      TE(i+1,j+1,k)-TE(i-1,j+1,k))/4.d0
       Q2E= TEjf-TEc
       Q3E=(TE(i,j,k+1)  -TE(i,j,k-1)+
     *      TE(i,j+1,k+1)-TE(i,j+1,k-1))/4.d0
      SI(1)=(SIX(i+1,j,k)+SIX(i+1,j+1,k)+SIX(i,j,k)+SIX(i,j+1,k))/4.d0
      SI(2)=(SIY(i+1,j,k)+SIY(i+1,j+1,k)+SIY(i,j,k)+SIY(i,j+1,k))/4.d0
      SI(3)=(SIZ(i+1,j,k)+SIZ(i+1,j+1,k)+SIZ(i,j,k)+SIZ(i,j+1,k))/4.d0
      SJ(1)=SJXf
      SJ(2)=SJYf
      SJ(3)=SJZf
      SK(1)=(SKX(i,j,k+1)+SKX(i,j+1,k+1)+SKX(i,j,k)+SKX(i,j+1,k))/4.d0
      SK(2)=(SKY(i,j,k+1)+SKY(i,j+1,k+1)+SKY(i,j,k)+SKY(i,j+1,k))/4.d0
      SK(3)=(SKZ(i,j,k+1)+SKZ(i,j+1,k+1)+SKZ(i,j,k)+SKZ(i,j+1,k))/4.d0
      CALL CF_VIS(Q1K,Q2K,Q3K,SI,SJ,SK,Voljf,SJ,vKjf,FVKjf)
      CALL CF_VIS(Q1E,Q2E,Q3E,SI,SJ,SK,Voljf,SJ,vEjf,FVEjf)

C======ÐÐ¯ÐÐÐÐ ÐÐÐ¢ÐÐ Ð§ÐÐ ÐÐ ÐÐ ÐÐÐ¬ k+1/2=========================
       Q1K=(TK(i+1,j,k)  -TK(i-1,j,k)+
     *      TK(i+1,j,k+1)-TK(i-1,j,k+1))/4.d0
       Q2K=(TK(i,j+1,k)  -TK(i,j-1,k)+
     *      TK(i,j+1,k+1)-TK(i,j-1,k+1))/4.d0
       Q3K= TKkf-TKc
C      --------------------------------------
       Q1E=(TE(i+1,j,k)  -TE(i-1,j,k)+
     *      TE(i+1,j,k+1)-TE(i-1,j,k+1))/4.d0
       Q2E=(TE(i,j+1,k)  -TE(i,j-1,k)+
     *      TE(i,j+1,k+1)-TE(i,j-1,k+1))/4.d0
       Q3E= TEkf-TEc
      SI(1)=(SIX(i+1,j,k)+SIX(i+1,j,k+1)+SIX(i,j,k)+SIX(i,j,k+1))/4.d0
      SI(2)=(SIY(i+1,j,k)+SIY(i+1,j,k+1)+SIY(i,j,k)+SIY(i,j,k+1))/4.d0
      SI(3)=(SIZ(i+1,j,k)+SIZ(i+1,j,k+1)+SIZ(i,j,k)+SIZ(i,j,k+1))/4.d0
      SJ(1)=(SJX(i,j+1,k)+SJX(i,j+1,k+1)+SJX(i,j,k)+SJX(i,j,k+1))/4.d0
      SJ(2)=(SJY(i,j+1,k)+SJY(i,j+1,k+1)+SJY(i,j,k)+SJY(i,j,k+1))/4.d0
      SJ(3)=(SJZ(i,j+1,k)+SJZ(i,j+1,k+1)+SJZ(i,j,k)+SJZ(i,j,k+1))/4.d0
      SK(1)=SKXf
      SK(2)=SKYf
      SK(3)=SKZf
      CALL CF_VIS(Q1K,Q2K,Q3K,SI,SJ,SK,Volkf,SK,vKkf,FVKkf)
      CALL CF_VIS(Q1E,Q2E,Q3E,SI,SJ,SK,Volkf,SK,vEkf,FVEkf)

C======ÐÐ¯ÐÐÐÐ ÐÐÐ¢ÐÐ Ð§ÐÐ ÐÐ ÐÐ ÐÐÐ¬ i-1/2=========================
      if(i.EQ.3) then
       jmm=j-1
       jpp=j+1
       kmm=k-1
       kpp=k+1
       ddj=0.25d0
       ddk=0.25d0
       if(k.eq.3)   then
          kmm=k
          ddk=0.5d0
       endif
       if(k.eq.K33) then
          kpp=k
          ddk=0.5d0
       endif
       Q1K= TKc-TKir
       Q2K=ddj*(TK(i-1,jpp,k)-TK(i-1,jmm,k)+
     *          TK(i  ,jpp,k)-TK(i  ,jmm,k))
       Q3K=ddk*(TK(i-1,j,kpp)-TK(i-1,j,kmm)+
     *          TK(i  ,j,kpp)-TK(i  ,j,kmm))
C      --------------------------------------
       Q1E= TEc-TEir
       Q2E=ddj*(TE(i-1,jpp,k)-TE(i-1,jmm,k)+
     *          TE(i  ,jpp,k)-TE(i  ,jmm,k))
       Q3E=ddk*(TE(i-1,j,kpp)-TE(i-1,j,kmm)+
     *          TE(i  ,j,kpp)-TE(i  ,j,kmm))
      SI(1)=SIXr
      SI(2)=SIYr
      SI(3)=SIZr
      SJ(1)=(SJX(i-1,j+1,k)+SJX(i,j+1,k)+SJX(i-1,j,k)+SJX(i,j,k))/4.d0
      SJ(2)=(SJY(i-1,j+1,k)+SJY(i,j+1,k)+SJY(i-1,j,k)+SJY(i,j,k))/4.d0
      SJ(3)=(SJZ(i-1,j+1,k)+SJZ(i,j+1,k)+SJZ(i-1,j,k)+SJZ(i,j,k))/4.d0
      SK(1)=(SKX(i-1,j,k+1)+SKX(i,j,k+1)+SKX(i-1,j,k)+SKX(i,j,k))/4.d0
      SK(2)=(SKY(i-1,j,k+1)+SKY(i,j,k+1)+SKY(i-1,j,k)+SKY(i,j,k))/4.d0
      SK(3)=(SKZ(i-1,j,k+1)+SKZ(i,j,k+1)+SKZ(i-1,j,k)+SKZ(i,j,k))/4.d0
      CALL CF_VIS(Q1K,Q2K,Q3K,SI,SJ,SK,Volir,SI,vKir,FVKir)
      CALL CF_VIS(Q1E,Q2E,Q3E,SI,SJ,SK,Volir,SI,vEir,FVEir)
      end if

C======ÐÐ¯ÐÐÐÐ ÐÐÐ¢ÐÐ Ð§ÐÐ ÐÐ ÐÐ ÐÐÐ¬ j-1/2=========================
      if(j.EQ.3) then
       Q1K=(TK(i+1,j-1,k)-TK(i-1,j-1,k)+
     *      TK(i+1,j,k)  -TK(i-1,j,k))/4.d0
       Q2K= TKc-TKjr
       Q3K=(TK(i,j-1,k+1)-TK(i,j-1,k-1)+
     *      TK(i,j,k+1)  -TK(i,j,k-1))/4.d0
C      --------------------------------------
       Q1E=(TE(i+1,j-1,k)-TE(i-1,j-1,k)+
     *      TE(i+1,j,k)  -TE(i-1,j,k))/4.d0
       Q2E= TEc-TEjr
       Q3E=(TE(i,j-1,k+1)-TE(i,j-1,k-1)+
     *      TE(i,j,k+1)  -TE(i,j,k-1))/4.d0
      SI(1)=(SIX(i+1,j-1,k)+SIX(i+1,j,k)+SIX(i,j-1,k)+SIX(i,j,k))/4.d0
      SI(2)=(SIY(i+1,j-1,k)+SIY(i+1,j,k)+SIY(i,j-1,k)+SIY(i,j,k))/4.d0
      SI(3)=(SIZ(i+1,j-1,k)+SIZ(i+1,j,k)+SIZ(i,j-1,k)+SIZ(i,j,k))/4.d0
      SJ(1)=SJXr
      SJ(2)=SJYr
      SJ(3)=SJZr
      SK(1)=(SKX(i,j-1,k+1)+SKX(i,j,k+1)+SKX(i,j-1,k)+SKX(i,j,k))/4.d0
      SK(2)=(SKY(i,j-1,k+1)+SKY(i,j,k+1)+SKY(i,j-1,k)+SKY(i,j,k))/4.d0
      SK(3)=(SKZ(i,j-1,k+1)+SKZ(i,j,k+1)+SKZ(i,j-1,k)+SKZ(i,j,k))/4.d0
      CALL CF_VIS(Q1K,Q2K,Q3K,SI,SJ,SK,Voljr,SJ,vKjr,FK0)
      CALL CF_VIS(Q1E,Q2E,Q3E,SI,SJ,SK,Voljr,SJ,vEjr,FE0)
      FVKjr(i)=FK0
      FVEjr(i)=FE0
      end if

C======ÐÐ¯ÐÐÐÐ ÐÐÐ¢ÐÐ Ð§ÐÐ ÐÐ ÐÐ ÐÐÐ¬ k-1/2=========================
c      if(k.EQ.3) then
       Q1K=(TK(i+1,j,k-1)-TK(i-1,j,k-1)+
     *      TK(i+1,j,k)  -TK(i-1,j,k))/4.d0
       Q2K=(TK(i,j+1,k-1)-TK(i,j-1,k-1)+
     *      TK(i,j+1,k)  -TK(i,j-1,k))/4.d0
       Q3K= TKc-TKkr
C      --------------------------------------
       Q1E=(TE(i+1,j,k-1)-TE(i-1,j,k-1)+
     *      TE(i+1,j,k)  -TE(i-1,j,k))/4.d0
       Q2E=(TE(i,j+1,k-1)-TE(i,j-1,k-1)+
     *      TE(i,j+1,k)  -TE(i,j-1,k))/4.d0
       Q3E= TEc-TEkr
      SI(1)=(SIX(i+1,j,k-1)+SIX(i+1,j,k)+SIX(i,j,k-1)+SIX(i,j,k))/4.d0
      SI(2)=(SIY(i+1,j,k-1)+SIY(i+1,j,k)+SIY(i,j,k-1)+SIY(i,j,k))/4.d0
      SI(3)=(SIZ(i+1,j,k-1)+SIZ(i+1,j,k)+SIZ(i,j,k-1)+SIZ(i,j,k))/4.d0
      SJ(1)=(SJX(i,j+1,k-1)+SJX(i,j+1,k)+SJX(i,j,k-1)+SJX(i,j,k))/4.d0
      SJ(2)=(SJY(i,j+1,k-1)+SJY(i,j+1,k)+SJY(i,j,k-1)+SJY(i,j,k))/4.d0
      SJ(3)=(SJZ(i,j+1,k-1)+SJZ(i,j+1,k)+SJZ(i,j,k-1)+SJZ(i,j,k))/4.d0
      SK(1)=SKXr
      SK(2)=SKYr
      SK(3)=SKZr
      CALL CF_VIS(Q1K,Q2K,Q3K,SI,SJ,SK,Volkr,SK,vKkr,FK0)
      CALL CF_VIS(Q1E,Q2E,Q3E,SI,SJ,SK,Volkr,SK,vEkr,FE0)
      FVKkr=FK0
      FVEkr=FE0
c      end if
c      write(*,*)('FV -DONE')

C***** Source terms: generation G and dissipation eps **********
       uim=0.5d0*(Qir(2)+Qc(2))
       vim=0.5d0*(Qir(3)+Qc(3))
       wim=0.5d0*(Qir(4)+Qc(4))

       ujm=0.5d0*(Qjr(2)+Qc(2))
       vjm=0.5d0*(Qjr(3)+Qc(3))
       wjm=0.5d0*(Qjr(4)+Qc(4))

       ukm=0.5d0*(Qkr(2)+Qc(2))
       vkm=0.5d0*(Qkr(3)+Qc(3))
       wkm=0.5d0*(Qkr(4)+Qc(4))

       uip=0.5d0*(Qc(2)+Qif(2))
       vip=0.5d0*(Qc(3)+Qif(3))
       wip=0.5d0*(Qc(4)+Qif(4))

       ujp=0.5d0*(Qc(2)+Qjf(2))
       vjp=0.5d0*(Qc(3)+Qjf(3))
       wjp=0.5d0*(Qc(4)+Qjf(4))

       ukp=0.5d0*(Qc(2)+Qkf(2))
       vkp=0.5d0*(Qc(3)+Qkf(3))
       wkp=0.5d0*(Qc(4)+Qkf(4))
c-----------------------------------
       ux=uip*SIXf - uim*SIXr +
     *    ujp*SJXf - ujm*SJXr +
     *    ukp*SKXf - ukm*SKXr
c-----------------------------------
       vx=vip*SIXf - vim*SIXr +
     *    vjp*SJXf - vjm*SJXr +
     *    vkp*SKXf - vkm*SKXr
c-----------------------------------
       wx=wip*SIXf - wim*SIXr +
     *    wjp*SJXf - wjm*SJXr +
     *    wkp*SKXf - wkm*SKXr
c-----------------------------------
       uy=uip*SIYf - uim*SIYr +
     *    ujp*SJYf - ujm*SJYr +
     *    ukp*SKYf - ukm*SKYr
c-----------------------------------
       vy=vip*SIYf - vim*SIYr +
     *    vjp*SJYf - vjm*SJYr +
     *    vkp*SKYf - vkm*SKYr
c-----------------------------------
       wy=wip*SIYf - wim*SIYr +
     *    wjp*SJYf - wjm*SJYr +
     *    wkp*SKYf - wkm*SKYr
c-----------------------------------
       uz=uip*SIZf - uim*SIZr +
     *    ujp*SJZf - ujm*SJZr +
     *    ukp*SKZf - ukm*SKZr
c-----------------------------------
       vz=vip*SIZf - vim*SIZr +
     *    vjp*SJZf - vjm*SJZr +
     *    vkp*SKZf - vkm*SKZr
c-----------------------------------
       wz=wip*SIZf - wim*SIZr +
     *    wjp*SJZf - wjm*SJZr +
     *    wkp*SKZf - wkm*SKZr
c-----------------------------------
       vt=Cmu*(TKc**2)/TEc  !! turbulent viscosity

C>     ÐÐ¾ ÑÐ¼Ð¾Ð»ÑÐ°Ð½Ð¸Ñ Ð´Ð»Ñ GG Ð¸ eps Ð¸ÑÐ¿Ð¾Ð»ÑÐ·ÑÑÑÑÑ ÑÐ¾ÑÐ¼ÑÐ»Ñ:
       GG=vt*(2.d0*(ux*ux+vy*vy+wz*wz+uy*vx+uz*wx+vz*wy)+
     *        uy*uy+uz*uz+vx*vx+vz*vz+wx*wx+wy*wy)/(Volc**2)

C=================================================================================
C>     ÐÐ»Ñ Ð¿ÑÐµÐ´Ð¾ÑÐ²ÑÐ°ÑÐµÐ½Ð¸Ñ ÑÐ¾ÑÑÐ° GG Ð² ÑÐ¾ÑÐºÐ°Ñ ÑÐ¾ÑÐ¼Ð¾Ð¶ÐµÐ½Ð¸Ñ Ð¿Ð¾ÑÐ¾ÐºÐ° Ð²Ð²ÐµÐ´ÐµÐ½ Ð¾Ð³ÑÐ°Ð½Ð¸ÑÐ¸ÑÐµÐ»Ñ,
C>     ÑÐ¾Ð³Ð»Ð°ÑÐ½Ð¾ ÑÐ°Ð±Ð¾ÑÐµ Durbin P. Ð. "Limiters and wall treatment in applied
C>     turbulence modeling", 2009.
C>     Ð­ÑÐ° Ð¼Ð¾Ð´Ð¸ÑÐ¸ÐºÐ°ÑÐ¸Ñ ÑÐµÑÐ°ÑÑÐ¸Ð¼ Ð¾Ð±ÑÐ°Ð·Ð¾Ð¼ ÑÑÑÑÐ°Ð½ÑÐµÑ Ð²ÑÐ±ÑÐ¾ÑÑ Ð½Ð° Ð£Ð¥ Ð´Ð»Ñ ÐÐ-ÑÑÑÐ±Ð¸Ð½ Ð¿ÑÐ¸ Ð¼Ð°Ð»ÑÑ Fi.
C>     Smod - Ð¼Ð¾Ð´ÑÐ»Ñ ÑÐµÐ½Ð·Ð¾ÑÐ° ÑÐºÐ¾ÑÐ¾ÑÑÐµÐ¹ Ð´ÐµÑÐ¾ÑÐ¼Ð°ÑÐ¸Ð¸ (strain-tensor) = ÐºÐ¾ÑÐµÐ½Ñ(2*Sij*Sij).
       Smod=DSQRT(2.d0*(ux*ux+vy*vy+wz*wz)+
     *            (uy+vx)**2+(uz+wx)**2+(vz+wy)**2)/Volc
       GG_k=DMIN1(GG,2.d0*TKc*Smod/DSQRT(3.d0))
C=================================================================================

       eps=TEc
       SrcK=eps/TKc
       SrcE=Ceps2*eps/TKc
       HK=GG_k            -SrcK*TKc
       HE=Ceps1*eps*GG/TKc-SrcE*TEc+Ceps3*GG*GG/TKc  !! ÐÐ»Ñ ÑÑÐ°Ð½Ð´Ð°ÑÑÐ½Ð¾Ð¹ k-e Ð¼Ð¾Ð´ÐµÐ»Ð¸ Ceps3=0.
       VolEff=Volc                                   !! Ð¢Ð°ÐºÐ¸Ð¼ Ð¾Ð±ÑÐ°Ð·Ð¾Ð¼, k-e ÑÐ¾Ð»Ð²ÐµÑ ÑÐ½Ð¸Ð²ÐµÑÑÐ°Ð»ÑÐ½ÑÐ¹,
                                                     !! Ð¿ÑÐ¸Ð³Ð¾Ð´Ð½ÑÐ¹ ÐºÐ°Ðº Ð´Ð»Ñ ÑÑÐ°Ð½Ð´Ð°ÑÑÐ½Ð¾Ð¹ k-e Ð¼Ð¾Ð´ÐµÐ»Ð¸,
                                                     !! ÑÐ°Ðº Ð¸ Ð´Ð»Ñ Kim-Chen Ð¼Ð¾Ð´ÐµÐ»Ð¸ ÑÑÑÐ±ÑÐ»ÐµÐ½ÑÐ½Ð¾ÑÑÐ¸.
c===========================================================================
C>     ÐÑÐ»Ð¸ ÑÑÐ´Ð¾Ð¼ ÑÐ²ÐµÑÐ´Ð°Ñ ÑÑÐµÐ½ÐºÐ°, ÑÐ¾ SrcK, GG Ð¸ eps Ð´Ð»Ñ k-ÑÑÐ°Ð²Ð½ÐµÐ½Ð¸Ñ, a ÑÐ°ÐºÐ¶Ðµ
C>     VolEff, HE Ð¸ SrcE Ð´Ð»Ñ e-ÑÑÐ°Ð²Ð½ÐµÐ½Ð¸Ñ Ð²ÑÑÐ¸ÑÐ»ÑÑÑÑÑ Ð´ÑÑÐ³Ð¸Ð¼ Ð¾Ð±ÑÐ°Ð·Ð¾Ð¼:

       isIwall=0
       isJwall=0
       isKwall=0
       SourceType=1

C====== I=3 BOUNDARY ===============================================
       if((i.EQ.3).AND.
     *   ((IZNAK.EQ.1).OR.
     *     ((BLOCK_SYMBOL.EQ.'a').AND.(j.GE.INTPAR(15))))) then
         CALL Find_Ge_wall(SourceType,Qc,SIXr,SIYr,SIZr,
     *            YPI(1,j,k),TKc,Cmu,Ckar,CE,Reyn,GG,eps1)
         CALL Find_eps_nw(TKc,YPI(1,j,k),Cmu,Ckar,eps_nw)
         isIwall=1
       endif

C====== I=K13 BOUNDARY =============================================
       if((i.eq.K13).AND.
     *    (((BLOCK_SYMBOL.EQ.'s').AND.(j.GE.INTPAR(15))).OR.
     *     ((nz_begin.gt.0).and.(NDOMN.eq.nz_begin+1)))) then
         CALL Find_Ge_wall(SourceType,Qc,SIXf,SIYf,SIZf,
     *            YPI(2,j,k),TKc,Cmu,Ckar,CE,Reyn,GG,eps1)
         CALL Find_eps_nw(TKc,YPI(2,j,k),Cmu,Ckar,eps_nw)
         isIwall=1
       endif

C====== J=3 BOUNDARY ===============================================
       if(j.eq.3) then
         Krot=0
         if(BLOCK_SYMBOL.eq.'k') then
           Xw=0.5d0*(X(I,2,K)+X(I,3,K))  !!
           Yw=0.5d0*(Y(I,2,K)+Y(I,3,K))  !! ÐÐ¾Ð¾ÑÐ´Ð¸Ð½Ð°ÑÑ Ð½Ð° ÑÑÐµÐ½ÐºÐµ
           Zw=0.5d0*(Z(I,2,K)+Z(I,3,K))  !!
           CALL STOB(1,Xw,Yw,Zw,REALPAR,IP)
           if((IP.eq.0).or.
     *       ((TurbineType.eq.'k').or.(TurbineType.eq.'K'))) Krot=1
         endif
         if((BLOCK_SYMBOL.eq.'z').and.(NDOMN.eq.nz_begin)) then
C          Ð Ð±Ð»Ð¾ÐºÐµ z01 ÑÑÐµÐ½ÐºÐ° j=3 - Ð²ÑÐ°ÑÐ°ÐµÑÑÑ.
           Krot=1
         endif
C        Krot=0 - ÑÑÐµÐ½ÐºÐ° Ð½ÐµÐ¿Ð¾Ð´Ð²Ð¸Ð¶Ð½Ð° Ð¾ÑÐ½Ð¾ÑÐ¸ÑÐµÐ»ÑÐ½Ð¾ Ð½Ð°ÑÐµÐ¹ ÑÐ¸ÑÑÐµÐ¼Ñ ÐºÐ¾Ð¾ÑÐ´Ð¸Ð½Ð°Ñ.
C        Krot=1 - ÑÑÐµÐ½ÐºÐ° Ð²ÑÐ°ÑÐ°ÐµÑÑÑ Ð¾ÑÐ½Ð¾ÑÐ¸ÑÐµÐ»ÑÐ½Ð¾ Ð½Ð°ÑÐµÐ¹ ÑÐ¸ÑÑÐµÐ¼Ñ ÐºÐ¾Ð¾ÑÐ´Ð¸Ð½Ð°Ñ.
         QcM(1)=Qc(1)
         QcM(2)=Qc(2)-Krot*OM*Y(i,j,k)
         QcM(3)=Qc(3)+Krot*OM*X(i,j,k)
         QcM(4)=Qc(4)
         CALL Find_Ge_wall(SourceType,QcM,SJXr,SJYr,SJZr,
     *            YPJ(1,i,k),TKc,Cmu,Ckar,CE,Reyn,GG,eps1)
         CALL Find_eps_nw(TKc,YPJ(1,i,k),Cmu,Ckar,eps_nw)
         isJwall=1
       endif

C====== J=K23 BOUNDARY =============================================
       XX=0.5d0*(X(I,J,K)+X(I,J+1,K))
       YY=0.5d0*(Y(I,J,K)+Y(I,J+1,K))
       RR=DSQRT(XX**2+YY**2)
       if((j.eq.K23).and.
     *   ((BLOCK_SYMBOL.ne.'k').or.(RR.ge.Rsrez))) then
         Krot=0
         if(BLOCK_SYMBOL.eq.'k') then
           Xw=0.5d0*(X(I,K23,K)+X(I,K22,K))  !!
           Yw=0.5d0*(Y(I,K23,K)+Y(I,K22,K))  !! ÐÐ¾Ð¾ÑÐ´Ð¸Ð½Ð°ÑÑ Ð½Ð° ÑÑÐµÐ½ÐºÐµ
           Zw=0.5d0*(Z(I,K23,K)+Z(I,K22,K))  !!
           CALL STOB(2,Xw,Yw,Zw,REALPAR,IP)
           if(IP.eq.0) Krot=1
         endif
C        Krot=0 - ÑÑÐµÐ½ÐºÐ° Ð½ÐµÐ¿Ð¾Ð´Ð²Ð¸Ð¶Ð½Ð° Ð¾ÑÐ½Ð¾ÑÐ¸ÑÐµÐ»ÑÐ½Ð¾ Ð½Ð°ÑÐµÐ¹ ÑÐ¸ÑÑÐµÐ¼Ñ ÐºÐ¾Ð¾ÑÐ´Ð¸Ð½Ð°Ñ.
C        Krot=1 - ÑÑÐµÐ½ÐºÐ° Ð²ÑÐ°ÑÐ°ÐµÑÑÑ Ð¾ÑÐ½Ð¾ÑÐ¸ÑÐµÐ»ÑÐ½Ð¾ Ð½Ð°ÑÐµÐ¹ ÑÐ¸ÑÑÐµÐ¼Ñ ÐºÐ¾Ð¾ÑÐ´Ð¸Ð½Ð°Ñ.
         QcM(1)=Qc(1)
         QcM(2)=Qc(2)-Krot*OM*Y(i,j,k)
         QcM(3)=Qc(3)+Krot*OM*X(i,j,k)
         QcM(4)=Qc(4)
         CALL Find_Ge_wall(SourceType,QcM,SJXf,SJYf,SJZf,
     *            YPJ(2,i,k),TKc,Cmu,Ckar,CE,Reyn,GG,eps1)
         CALL Find_eps_nw(TKc,YPJ(2,i,k),Cmu,Ckar,eps_nw)
         isJwall=1
       endif

C====== K=3 BOUNDARY ===============================================
       if((k.eq.3).and.(KRT2(i,j,1).eq.1)) then
         CALL Find_Ge_wall(SourceType,Qc,SKXr,SKYr,SKZr,
     *            YPK(1,i,j),TKc,Cmu,Ckar,CE,Reyn,GG,eps1)
         CALL Find_eps_nw(TKc,YPK(1,i,j),Cmu,Ckar,eps_nw)
         isKwall=1
       endif

C====== K=K33 BOUNDARY =============================================
       if((k.eq.K33).and.(KRT1(i,j,1).eq.1)) then
         CALL Find_Ge_wall(SourceType,Qc,SKXf,SKYf,SKZf,
     *            YPK(2,i,j),TKc,Cmu,Ckar,CE,Reyn,GG,eps1)
         CALL Find_eps_nw(TKc,YPK(2,i,j),Cmu,Ckar,eps_nw)
         isKwall=1
       endif

C====== Ð ÐÐ¡Ð§ÐÐ¢ HK,HE,SrcK,SrcE Ð²Ð±Ð»Ð¸Ð·Ð¸ ÑÑÐµÐ½ÐºÐ¸ =======================
       if((isIwall.eq.1).or.(isJwall.eq.1).or.(isKwall.eq.1)) then
         SrcK=eps1/TKc
         HK=GG-SrcK*TKc

         SrcE=0.d0
         HE=(eps_nw-TEc)/TAU
         VolEff=VeryLargeNumber
       endif
c===========================================================================

C      Ð Ð°ÑÑÐµÑ eps Ð¿ÐµÑÐµÐ´ Ð²ÑÐ¾Ð´Ð½Ð¾Ð¹ ÐºÑÐ¾Ð¼ÐºÐ¾Ð¹ Ð¸ ÑÑÐ°Ð·Ñ Ð·Ð° Ð²ÑÑÐ¾Ð´Ð½Ð¾Ð¹ ÐºÑÐ¾Ð¼ÐºÐ¾Ð¹ Ð»Ð¾Ð¿Ð°ÑÑÐ¸
C      Ð¿Ð¾ ÑÐ¾ÑÐ¼ÑÐ»Ðµ eps_nw, ÐºÐ°Ðº Ð½Ð° ÑÐ²ÐµÑÐ´Ð¾Ð¹ ÑÑÐµÐ½ÐºÐµ.
       isKcorner=0
C====== K=3 BOUNDARY, BEFORE AND BEHIND BLADE ==============================
       if((k.eq.3).and.(KRT2(i,j,1).ne.1)) then
         if((KRT2(i+1,j,1).eq.1).or.
     *      (KRT2(i-1,j,1).eq.1)) then
           CALL Find_eps_nw(TKc,YPK(1,i,j),Cmu,Ckar,eps_nw)
           isKcorner=1
         endif
       endif
C====== K=K33 BOUNDARY, BEFORE AND BEHIND BLADE ============================
       if((k.eq.K33).and.(KRT1(i,j,1).ne.1)) then
         if((KRT1(i+1,j,1).eq.1).or.
     *      (KRT1(i-1,j,1).eq.1)) then
           CALL Find_eps_nw(TKc,YPK(2,i,j),Cmu,Ckar,eps_nw)
           isKcorner=1
         endif
       endif
       if(isKcorner.eq.1) then
         SrcE=0.d0
         HE=(eps_nw-TEc)/TAU
         VolEff=VeryLargeNumber
       endif

C*** RHSK Ð¸ RHSE ***********************************************************
       RHSK(i,j,k)= -(FNKif+FVKif-FNKir     -FVKir+
     *         FNKjf+FVKjf-FNKjr(i)  -FVKjr(i)+
     *         FNKkf+FVKkf-FNKkr-FVKkr)+ ! FNKkr(i,j)-FVKkr(i,j)
     *         HK*Volc
       RHSE(i,j,k)= -(FNEif+FVEif-FNEir     -FVEir+
     *         FNEjf+FVEjf-FNEjr(i)  -FVEjr(i)+
     *         FNEkf+FVEkf-FNEkr-FVEkr)+ ! FNEkr(i,j)-FVEkr(i,j)
     *         HE*VolEff

C*** Evaluation of Residual ******************
       ResK=DABS(RHSK(i,j,k))/Volc
       ResE=DABS(RHSE(i,j,k))/VolEff
       if(ResK.GT.ResKMax) ResKMax=ResK
       if(ResE.GT.ResEMax) ResEMax=ResE

       if(ResK.LE.1.e-16) then
         ResMK(i,j,k)=-16.d0
       else
         ResMK(i,j,k)=DLOG(ResK)/DLOG(10.d0)
       end if

       if(ResE.LE.1.e-16) then
         ResME(i,j,k)=-16.d0
       else
         ResME(i,j,k)=DLOG(ResE)/DLOG(10.d0)
       end if

       SumDivK=SumDivK+ResK*ResK*Volc
       SumDivE=SumDivE+ResE*ResE*Volc
       SumVol =SumVol+Volc
c       write(*,*)('Res -DONE')

C*** C-scalars *******************************
       CirK=BirK-Apir
       CjrK=BjrK-Apjr
       CkrK=BkrK-Apkr
       CifK=BifK+Amif
       CjfK=BjfK+Amjf
       CkfK=BkfK+Amkf

       CirE=BirE-Apir
       CjrE=BjrE-Apjr
       CkrE=BkrE-Apkr
       CifE=BifE+Amif
       CjfE=BjfE+Amjf
       CkfE=BkfE+Amkf

C*** D-scalars *******************************
       DK=  Volc*(1.d0/TAU+SrcK)-(CirK+CjrK+CkrK+CifK+CjfK+CkfK)
       DE=VolEff*(1.d0/TAU+SrcE)-(CirE+CjrE+CkrE+CifE+CjfE+CkfE)
c       write(*,*) DK,DE,TAU
c       if(DABS(DK).LT.1.e-16) PAUSE "DK is small"
c       if(DABS(DE).LT.1.e-16) PAUSE "DE is small"

C*** EXCHANGE *******************
       FNKir     =FNKif
       FVKir     =FVKif
       FNKjr(i)  =FNKjf
       FVKjr(i)  =FVKjf
!! uses in 1-proc version without OpenMP
!       FNKkr(i,j)=FNKkf
!       FVKkr(i,j)=FVKkf
!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!
       FNEir     =FNEif
       FVEir     =FVEif
       FNEjr(i)  =FNEjf
       FVEjr(i)  =FVEjf
!! uses in 1-proc version without OpenMP
!       FNEkr(i,j)=FNEkf
!       FVEkr(i,j)=FVEkf
!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!

C*** REMEMBERING ****************
       DKM(i,j,k)=DK
       DEM(i,j,k)=DE

       CirKM(i,j,k)=CirK
       CjrKM(i,j,k)=CjrK
       CkrKM(i,j,k)=CkrK
       CirEM(i,j,k)=CirE
       CjrEM(i,j,k)=CjrE
       CkrEM(i,j,k)=CkrE

       CifKM(i,j,k)=CifK
       CjfKM(i,j,k)=CjfK
       CkfKM(i,j,k)=CkfK
       CifEM(i,j,k)=CifE
       CjfEM(i,j,k)=CjfE
       CkfEM(i,j,k)=CkfE
560   CONTINUE

C*** THE END of UP-RUNCOUNT ************************************
C  < ÐÐ°ÐºÐ¾Ð½ÑÐ¸Ð»Ð¸ Ð±ÐµÐ³ÑÑÐ¸Ð¹ ÑÑÐµÑ Ð²Ð²ÐµÑÑ. ÐÐ¾Ð½ÐµÑ Ð¿ÐµÑÐ²Ð¾Ð³Ð¾ Ð¿Ð¾Ð»ÑÑÐ°Ð³Ð°. >
c      write(*,*)(' UP - finished')

C***** THE BEGINNING OF UP-RUNCOUNT ******************************
C*** New PSYmK and PSYmE *********************
      DO 660 SumIJK=9,K13+K23+K33
!$omp do
      DO 660 SumJK=max(6,SumIJK-K13),min(K23+K33,SumIJK-3)
      DO 660 K=max(3,SumJK-K23),min(K33,SumJK-3)
         J=SumJK-K
         I=SumIJK-K-J
       PSYmK(i,j,k)=(RHSK(i,j,k)-CirKM(i,j,k)*PSYmK(i-1,j,k)-
     *                    CjrKM(i,j,k)*PSYmK(i,j-1,k)-
     *                    CkrKM(i,j,k)*PSYmK(i,j,k-1))/DKM(i,j,k)
       PSYmE(i,j,k)=(RHSE(i,j,k)-CirEM(i,j,k)*PSYmE(i-1,j,k)-
     *                    CjrEM(i,j,k)*PSYmE(i,j-1,k)-
     *                    CkrEM(i,j,k)*PSYmE(i,j,k-1))/DEM(i,j,k)
660   CONTINUE
C*** THE END OF UP-RUNCOUNT **********************************
c      write(*,*)(' UP - finished')

!$omp do
      DO 590 j=3,K23
      DO 590 i=3,K13
        dPsiK(i,j,K32)=0.d0
590     dPsiE(i,j,K32)=0.d0
!$omp do
      DO 592 k=3,K33
      DO 592 j=3,K23
        dPsiK(K12,j,k)=0.d0
592     dPsiE(K12,j,k)=0.d0
!$omp do
      DO 594 k=3,K33
      DO 594 i=3,K13
        dPsiK(i,K22,k)=0.d0
594     dPsiE(i,K22,k)=0.d0

C*** THE BEGINING OF DOWN-RUNCOUNT *****************************
      DO 680 SumIJK=9,K13+K23+K33
!$omp do
      DO 680 SumJK=max(6,SumIJK-K13),min(K23+K33,SumIJK-3)
      DO 680 Knn=max(3,SumJK-K23),min(K33,SumJK-3)
         Jnn=SumJK-Knn
         Inn=SumIJK-Knn-Jnn
        k=K3-Knn
        j=K2-Jnn
        i=K1-Inn
        dPsiK(i,j,k)=PSYmK(i,j,k) -
     *                  (CifKM(i,j,k)*dPsiK(i+1,j,k)+
     *                   CjfKM(i,j,k)*dPsiK(i,j+1,k)+
     *                   CkfKM(i,j,k)*dPsiK(i,j,k+1))/DKM(i,j,k)
        dPsiE(i,j,k)=PSYmE(i,j,k) -
     *                  (CifEM(i,j,k)*dPsiE(i+1,j,k)+
     *                   CjfEM(i,j,k)*dPsiE(i,j+1,k)+
     *                   CkfEM(i,j,k)*dPsiE(i,j,k+1))/DEM(i,j,k)
680   CONTINUE
C*** THE END OF DOWN-RUNCOUNT **********************************
c      write(*,*)(' DOWN - finished')

!$omp do
      DO 800 k=3,K33
      DO 800 j=3,K23
      DO 800 i=3,K13
        TK(i,j,k)=TK(i,j,k)+dPsiK(i,j,k)
        TE(i,j,k)=TE(i,j,k)+dPsiE(i,j,k)
800   CONTINUE

C===============================================================
C     ÐÐ¾ÑÑÐµÐºÑÐ¸Ñ Ð¿Ð¾Ð»ÐµÐ¹ k Ð¸ eps.
C     ÐÐ»Ñ Ð¾ÑÐºÐ»ÑÑÐµÐ½Ð¸Ñ ÐºÐ¾ÑÑÐµÐºÑÐ¸Ð¸ Ð½ÐµÐ¾Ð±ÑÐ¾Ð´Ð¸Ð¼Ð¾ ÑÐ°ÑÐºÐ¾Ð¼Ð¼ÐµÐ½ÑÐ¸ÑÐ¾Ð²Ð°ÑÑ
C     ÑÐ»ÐµÐ´ÑÑÑÑÑ ÑÑÑÐ¾ÐºÑ:

c      GOTO 900
C===============================================================
      NKnegCorr=0
      NEnegCorr=0
      NEcutCorr=0
      KSDV(1,1)= -1
      KSDV(1,2)=  0
      KSDV(1,3)=  0
      KSDV(2,1)=  1
      KSDV(2,2)=  0
      KSDV(2,3)=  0
      KSDV(3,1)=  0
      KSDV(3,2)= -1
      KSDV(3,3)=  0
      KSDV(4,1)=  0
      KSDV(4,2)=  1
      KSDV(4,3)=  0
      KSDV(5,1)=  0
      KSDV(5,2)=  0
      KSDV(5,3)= -1
      KSDV(6,1)=  0
      KSDV(6,2)=  0
      KSDV(6,3)=  1
!$omp do
      DO 840 k=3,K33
      DO 840 j=3,K23
      DO 840 i=3,K13
        if(TK(i,j,k).LT.1.e-16) then
C          print *, "TK=",TK(i,j,k),"   i,j,k,=",i,j,k
C          print *, 'Correcting TK.'
CC         ÐÐµÑÐµÐ¼ ÑÑÐµÐ´Ð½ÐµÐµ ÑÑÐµÐ´Ð¸ Ð±Ð»Ð¸Ð¶Ð°Ð¹ÑÐ¸Ñ Ð¿Ð¾Ð»Ð¾Ð¶Ð¸ÑÐµÐ»ÑÐ½ÑÑ.
          NKnegCorr=NKnegCorr+1
          TKsum=0.d0
          MP=0
          DO 810 m=1,6
            is=i+KSDV(m,1)
            js=j+KSDV(m,2)
            ks=k+KSDV(m,3)
            if((TK(is,js,ks).gt.1.e-16).and.
     *         (js.ge.3).and.(js.le.K23).and.
     *         (ks.ge.3).and.(ks.le.K33)) then
              TKsum=TKsum+TK(is,js,ks)
              MP=MP+1
            endif
810       CONTINUE
          TK(i,j,k)=TKsum/MP
        endif

C===============================================================
       if(TE(i,j,k).LT.1.e-16) then
C          print *, "TE=",TE(i,j,k),"   i,j,k,=",i,j,k
C          print *, 'Correcting TE.'
          NEnegCorr=NEnegCorr+1
          TELoc(1)=TE(i-1,j,k)
          TELoc(2)=TE(i+1,j,k)
          TELoc(3)=TE(i,j-1,k)
          TELoc(4)=TE(i,j+1,k)
          TELoc(5)=TE(i,j,k-1)
          TELoc(6)=TE(i,j,k+1)
          TEmin=1.e+20
C         ÐÐµÑÐµÐ¼ Ð¼Ð¸Ð½Ð¸Ð¼ÑÐ¼ ÑÑÐµÐ´Ð¸ Ð±Ð»Ð¸Ð¶Ð°Ð¹ÑÐ¸Ñ.
          DO 820 m=1,6
            if((TELoc(m).lt.TEmin).and.(TELoc(m).gt.1.e-16)) then
              TEmin=TELoc(m)
            endif
820       CONTINUE
          TE(i,j,k)=TEmin
        endif
840   CONTINUE

C===============================================================
!$omp do
      DO 870 k=3,K33
      DO 870 j=3,K23
      DO 870 i=3,K13
        TEmedium=(TE(i-1,j,k)+TE(i,j-1,k)+TE(i,j,k-1)+
     *            TE(i+1,j,k)+TE(i,j+1,k)+TE(i,j,k+1))/6.d0
        TEcut=TEmedium/5.d0
        if(TE(i,j,k).LT.TEcut) then
          vtc = Cmu*(TK(i,j,k)**2)/TE(i,j,k)
          vtir= Cmu*(TK(i-1,j,k)**2)/TE(i-1,j,k)
          vtif= Cmu*(TK(i+1,j,k)**2)/TE(i+1,j,k)
          vtjr= Cmu*(TK(i,j-1,k)**2)/TE(i,j-1,k)
          vtjf= Cmu*(TK(i,j+1,k)**2)/TE(i,j+1,k)
          vtkr= Cmu*(TK(i,j,k-1)**2)/TE(i,j,k-1)
          vtkf= Cmu*(TK(i,j,k+1)**2)/TE(i,j,k+1)
          vtmax=DMAX1(vtir,vtif,vtjr,vtjf,vtkr,vtkf)
          if(vtc.gt.vtmax) then
C            print 872,TE(i,j,k),TEcut,i,j,k
C872         FORMAT('TE=',E11.4,'   TEcut=',E11.4,
C     *             '  i,j,k,=',I4,I4,I4)
C            print *, '=====>>> Corrrecting.'
            NEcutCorr=NEcutCorr+1
            TE(i,j,k)=TEcut
          endif
        endif
870   CONTINUE

!$omp end parallel
      if(ReturnFlag) RETURN

C==== ÐÑÐ´Ð°ÑÐ° ÑÐ¾Ð¾Ð±ÑÐµÐ½Ð¸Ñ Ð½Ð° ÑÐºÑÐ°Ð½ ================================
      if(((NKnegCorr+NEnegCorr+NEcutCorr).gt.0).AND.IsPrint) then
        print 890,NKnegCorr,NEnegCorr,NEcutCorr
890     FORMAT(12X,'CORRECTION [K-neg:',I4,
     *         ';  E-neg:',I4,';  E-cut:',I4,']')
      endif
C==== ÐÐ¾ÑÑÐµÐºÑÐ¸Ñ Ð¿Ð¾Ð»ÐµÐ¹ k Ð¸ eps Ð·Ð°ÐºÐ¾Ð½ÑÐµÐ½Ð° ========================

900   CONTINUE
      RETURN
      END

      SUBROUTINE CF_IN(Q1,Q2,qm1,qm2,Sx,Sy,Sz,Flux)
      IMPLICIT REAL*8 (A-H,O-Z)
      DIMENSION Q1(4),Q2(4)

C     ÐÑÐ¾ÑÐµÐ´ÑÑÐ° Ð´Ð»Ñ Ð²ÑÑÐ¸ÑÐ»ÐµÐ½Ð¸Ñ Ð½ÐµÐ²ÑÐ·ÐºÐ¾Ð³Ð¾ Ð¿Ð¾ÑÐ¾ÐºÐ° k Ð¸Ð»Ð¸ eps ÑÐµÑÐµÐ· Ð³ÑÐ°Ð½Ñ m+1/2.
C     Q1,Q2 - Ð²ÐµÐºÑÐ¾ÑÐ° (p,u,v,w) Ð² ÑÐ¾ÑÐºÐ°Ñ m,m+1,
C     qm1,qm2 - Ð·Ð½Ð°ÑÐµÐ½Ð¸Ñ k Ð¸Ð»Ð¸ eps Ð² ÑÐ¾ÑÐºÐ°Ñ m,m+1.
C     ÐÑÐ¿Ð¾Ð»ÑÐ·ÑÐµÑÑÑ ÑÑÐµÐ¼Ð° Ð¿ÐµÑÐ²Ð¾Ð³Ð¾ Ð¿Ð¾ÑÑÐ´ÐºÐ°.

      A=0.5d0*((Q1(2)+Q2(2))*Sx+(Q1(3)+Q2(3))*Sy+(Q1(4)+Q2(4))*Sz)

      RS1=qm1*(Q1(2)*Sx+Q1(3)*Sy+Q1(4)*Sz)
      RS2=qm2*(Q2(2)*Sx+Q2(3)*Sy+Q2(4)*Sz)

      Flux=0.5d0*(RS1+RS2-DABS(A)*(qm2-qm1))
      RETURN
      END



c8888888888888888888888888888888888888888888888888888888888888888888888
c8888888888888888888888888888888888888888888888888888888888888888888888

      SUBROUTINE CF_VIS(QE1,QE2,QE3,SI,SJ,SK,Vol,Sm,vK,Fvis)
      IMPLICIT REAL*8 (A-H,O-Z)
      DIMENSION SI(3),SJ(3),SK(3),Sm(3)

C     ÐÑÐ¾ÑÐµÐ´ÑÑÐ° Ð´Ð»Ñ Ð²ÑÑÐ¸ÑÐ»ÐµÐ½Ð¸Ñ Ð²ÑÐ·ÐºÐ¾Ð³Ð¾ Ð¿Ð¾ÑÐ¾ÐºÐ° ÑÐµÑÐµÐ· Ð³ÑÐ°Ð½Ñ.
C     t={k Ð¸Ð»Ð¸ eps}
      t_x=(QE1*SI(1)+QE2*SJ(1)+QE3*SK(1))/Vol
      t_y=(QE1*SI(2)+QE2*SJ(2)+QE3*SK(2))/Vol
      t_z=(QE1*SI(3)+QE2*SJ(3)+QE3*SK(3))/Vol
      Fvis=-vK*(t_x*Sm(1)+t_y*Sm(2)+t_z*Sm(3))
      RETURN
      END


c8888888888888888888888888888888888888888888888888888888888888888888888
c8888888888888888888888888888888888888888888888888888888888888888888888

      SUBROUTINE Find_Ge_wall(SourceType,Q1,Sx,Sy,Sz,yp,TK,
     *                                   Cmu,Ckar,CE,Reyn,G,eps)
      IMPLICIT REAL*8 (A-H,O-Z)
      REAL*8 nx,ny,nz,nu_wall
      INTEGER SourceType
      DIMENSION Q1(4)

C     ÐÑÐ¾ÑÐµÐ´ÑÑÐ° Ð½Ð°ÑÐ¾Ð¶Ð´ÐµÐ½Ð¸Ñ ÑÐ»ÐµÐ½Ð° Ð³ÐµÐ½ÐµÑÐ°ÑÐ¸Ð¸ G Ð¸ Ð´Ð¸ÑÑÐ¸Ð¿Ð°ÑÐ¸Ð¸ eps, Ð²ÑÐ¾Ð´ÑÑÐ¸Ñ Ð² Ð¸ÑÑÐ¾ÑÐ½Ð¸Ðº.
C     ÐÑÐµÐ´Ð¿Ð¾Ð»Ð°Ð³Ð°ÐµÑÑÑ, ÑÑÐ¾ yp Ð½Ð°ÑÐ¾Ð´Ð¸ÑÑÑ Ð² Ð»Ð¾Ð³Ð°ÑÐ¸ÑÐ¼Ð¸ÑÐµÑÐºÐ¾Ð¼ ÑÐ»Ð¾Ðµ (30< y+ <300).
C     Ð¡Ð¿Ð¾ÑÐ¾Ð± Ð²ÑÑÐ¸ÑÐ»ÐµÐ½Ð¸Ñ: SOURCE1 Ð¸Ð»Ð¸ SOURCE3 (ÑÐ¼. Ð¾Ð¿Ð¸ÑÐ°Ð½Ð¸Ðµ ÑÐ¾Ð»Ð²ÐµÑÐ° STREAM 4.5.2),
C     Ð¾Ð¿ÑÐµÐ´ÐµÐ»ÑÐµÑÑÑ Ð¿Ð°ÑÐ°Ð¼ÐµÑÑÐ¾Ð¼ SourceType (SourceType= 1 Ð¸Ð»Ð¸ 3).

      SS=DSQRT(Sx**2+Sy**2+Sz**2)
      if(SS.gt.1.e-20) then
        nx=Sx/SS
        ny=Sy/SS
        nz=Sz/SS
      else
        nx=0.d0
        ny=0.d0
        nz=0.d0
      endif
      u=Q1(2)
      v=Q1(3)
      w=Q1(4)
      Un=u*nx+v*ny+w*nz
      Utx=u-Un*nx
      Uty=v-Un*ny
      Utz=w-Un*nz

      CM14K12=(Cmu**0.25d0)*DSQRT(TK)
      y_plus=CM14K12*yp*Reyn
C     ÐÐ¾Ð³Ð°ÑÐ¸ÑÐ¼Ð¸ÑÐµÑÐºÐ¸Ð¹ Ð·Ð°ÐºÐ¾Ð½ Ð´Ð»Ñ Ð²ÑÑÐ¸ÑÐ»ÐµÐ½Ð¸Ñ tau_w:
c      nu_wall=(1.d0/Reyn)*Ckar*y_plus/DLOG(CE*y_plus)
C     ÐÑÐ·ÐºÐ¸Ð¹ Ð¸Ð»Ð¸ Ð»Ð¾Ð³Ð°ÑÐ¸ÑÐ¼Ð¸ÑÐµÑÐºÐ¸Ð¹ Ð·Ð°ÐºÐ¾Ð½ Ð´Ð»Ñ tau_w:

C     Ð§ÑÐ¾Ð±Ñ Ð² Ð¿ÑÐ¾ÑÐµÑÑÐµ ÑÑÑÐ°Ð½Ð¾Ð²Ð»ÐµÐ½Ð¸Ñ Ð½Ðµ Ð¿ÑÐ¾Ð¸ÑÑÐ¾Ð´Ð¸Ð»Ð¾ Ð´ÐµÐ»ÐµÐ½Ð¸Ðµ
C     Ð½Ð° Ð¾ÑÐµÐ½Ñ Ð¼Ð°Ð»ÐµÐ½ÑÐºÐ¾Ðµ ÑÐ¸ÑÐ»Ð¾ (Ð¿ÑÐ¸ y_plus Ð±Ð»Ð¸Ð·ÐºÐ¾Ð¼ Ðº 0.112),
C     Ð¾Ð³ÑÐ°Ð½Ð¸ÑÐ¸Ð¼ y_plus, ÑÐµÑÐµÐ· ÐºÐ¾ÑÐ¾ÑÑÐ¹ Ð²ÑÑÐ¸ÑÐ»ÑÐµÑÑÑ nu_wall.
C     Ð­ÑÐ¾ Ð½Ðµ Ð²Ð»Ð¸ÑÐµÑ Ð½Ð° ÑÐ¾ÑÐ½Ð¾ÑÑÑ ÑÐ°ÑÑÐµÑÐ°, ÑÐ°Ðº ÐºÐ°Ðº Ð²ÑÐµ ÑÐ°Ð²Ð½Ð¾
C     Ð¿ÑÐ¸ Ð²ÑÑÐ¸ÑÐ»ÐµÐ½Ð¸Ð¸ nu_wall Ð±ÑÐ´ÐµÑ Ð²Ð·ÑÑ DMAX1.
      y_plus1=DMAX1(1.d0,y_plus)
      nu_wall=(1.d0/Reyn)*DMAX1(1.d0,Ckar*y_plus1/DLOG(CE*y_plus1))

      G=(nu_wall**2)*(Utx**2+Uty**2+Utz**2)/(Ckar*CM14K12*(yp**3))
      eps=(CM14K12**3)/(Ckar*yp)
      if(SourceType.eq.3) then
        G  =G  *DLOG(CE*y_plus)
        eps=eps*DLOG(CE*y_plus)
      endif
      RETURN
      END


c8888888888888888888888888888888888888888888888888888888888888888888888
c8888888888888888888888888888888888888888888888888888888888888888888888

      SUBROUTINE Find_eps_nw(TK,yp,Cmu,Ckar,eps_nw)
      IMPLICIT REAL*8 (A-H,O-Z)
C     ÐÑÐ¾ÑÐµÐ´ÑÑÐ° Ð½Ð°ÑÐ¾Ð¶Ð´ÐµÐ½Ð¸Ñ eps_nw.
C     ÐÑÐµÐ´Ð¿Ð¾Ð»Ð°Ð³Ð°ÐµÑÑÑ, ÑÑÐ¾ yp Ð½Ð°ÑÐ¾Ð´Ð¸ÑÑÑ Ð² Ð»Ð¾Ð³Ð°ÑÐ¸ÑÐ¼Ð¸ÑÐµÑÐºÐ¾Ð¼ ÑÐ»Ð¾Ðµ (30< y+ <300).
      eps_nw=(Cmu**0.75d0)*(TK**1.5d0)/(Ckar*yp)
      RETURN
      END

c8888888888888888888888888888888888888888888888888888888888888888888888
c8888888888888888888888888888888888888888888888888888888888888888888888
					</code></pre>
				</section>
				<section>
					<h3 style="text-align: left">Java Code Example from 2018</h3>
					<pre><code class="language-java">
package ru.yandex.assay.accuracy.evaluation;

import org.jetbrains.annotations.Nullable;
import ru.yandex.assay.accuracy.model.AttributeChange;
import ru.yandex.assay.accuracy.model.CompanyChange;
import ru.yandex.assay.altay.tds.TDSLangString;
import ru.yandex.assay.altay.tds.model.AbstractTDSCompany.PublishingStatus;
import ru.yandex.assay.altay.tds.model.AbstractTDSName.Type;
import ru.yandex.assay.altay.tds.model.TDSAddress;
import ru.yandex.assay.altay.tds.model.TDSAddress.TDSPosition;
import ru.yandex.assay.altay.tds.model.TDSCompany;
import ru.yandex.assay.altay.tds.model.TDSCompany.TDSCompanyRubric;
import ru.yandex.assay.altay.tds.model.TDSName;
import ru.yandex.assay.altay.tds.model.TDSPhone;
import ru.yandex.assay.altay.tds.model.TDSUrl;
import ru.yandex.assay.altay.tds.model.TDSWorkInterval;
import ru.yandex.assay.altay.unification.UnifierApi;
import ru.yandex.qe.util.enums.LangIso639;
import java.util.ArrayList;
import java.util.Arrays;
import java.util.Collections;
import java.util.List;
import java.util.function.Function;
import java.util.stream.Collectors;

public class CompanyChangeToTdsCompany {
	public CompanyChangeToTdsCompany(@Nullable UnifierApi unifier) {
		this.unifier = unifier;
	}

	private final UnifierApi unifier;

	public TDSCompany convertActual(CompanyChange companyChange, LangIso639 lang) {
		return convert(companyChange, lang, AttributeChange::before);
	}

	public TDSCompany convertExpected(CompanyChange companyChange, LangIso639 lang) {
		return convert(companyChange, lang, AttributeChange::after);
	}

	private TDSCompany convert(CompanyChange companyChange, LangIso639 lang,
			Function<AttributeChange, String> function) {
		PublishingStatus ps = PublishingStatus.valueOf(function.apply(
				companyChange.publishingStatusChange()));

		List<TDSName> names = Arrays.asList(
				TDSName.of(TDSLangString.of(lang, function.apply(companyChange.nameChange())), Type.MAIN),
				TDSName.of(TDSLangString.of(lang, function.apply(companyChange.shortNameChange())), Type.SHORT)
		);
		double lat = 0.0;
		double lon = 0.0;
		String latlon = function.apply(companyChange.coordinateChange());
		if (!latlon.isEmpty()) {
			lat = Double.parseDouble(latlon.split(",")[0].split(" ")[0]);
			lon = Double.parseDouble(latlon.split(",")[1].split(" ")[0]);
		}

		TDSAddress tdsAddress = TDSAddress.empty()
				.withFormatted(TDSLangString.of(lang, function.apply(companyChange.addressChange())))
				.withPos(TDSPosition.of(lon, lat));

		List<TDSPhone> phones = Arrays.stream(function.apply(companyChange.phoneChange()).split(";"))
				.filter(x -> !x.isEmpty())
				.map(x -> TDSPhone.builder().number(x).formatted(x).build())
				.collect(Collectors.toList());

		List<TDSCompanyRubric> rubrics = Arrays.stream(function.apply(companyChange.rubricChange()).split(";"))
				.filter(x -> !x.isEmpty())
				.map(x -> TDSCompanyRubric.builder().id(Long.parseLong(x)).build())
				.collect(Collectors.toList());

		List<TDSUrl> urls = new ArrayList<>();
		Arrays.stream(function.apply(companyChange.urlChange()).split(";"))
				.filter(x -> !x.isEmpty())
				.map(x -> TDSUrl.of(x, TDSUrl.Type.MAIN))
				.forEach(urls::add);
		Arrays.stream(function.apply(companyChange.alternativeUrlChange()).split(";"))
				.filter(x -> !x.isEmpty())
				.map(x -> TDSUrl.of(x, TDSUrl.Type.ALTERNATIVE))
				.forEach(urls::add);
		Arrays.stream(function.apply(companyChange.socialUrlChange()).split(";"))
				.filter(x -> !x.isEmpty())
				.map(x -> TDSUrl.of(x, TDSUrl.Type.SOCIAL))
				.forEach(urls::add);
		List<TDSWorkInterval> workIntervals = Collections.emptyList();
		if (unifier != null) {
			workIntervals = unifier.unifyWorkingTime(function.apply(companyChange.workingTimeChange()));
		}

		return TDSCompany.empty()
				.withPublishingStatus(ps)
				.withNames(names)
				.withAddress(tdsAddress)
				.withPhones(phones)
				.withRubrics(rubrics)
				.withUrls(urls)
				.withWorkIntervals(workIntervals);
	}
}
					</code></pre>
				</section>
			</section>
			<section>
				<section>
					<h3 style="text-align: left">Design Patterns in Open Source Projects</h3>
					<div class="fragment">
						<div class="typesetting">
							<p style="text-align: left">
								Exploring how established open source projects implement
								design patterns offers insights into practical applications and
								benefits.</p>
							<ul>
								<li><strong class="important">Spring Framework (Java):</strong>
									Employs the Singleton pattern extensively for bean management,
									ensuring efficient, consistent object access throughout the application
									lifecycle
								</li>
								<li><strong class="important">React (JavaScript):</strong>
									Uses the Observer pattern to manage state and props changes,
									enabling dynamic UI updates in response to data modifications
								</li>
							</ul>
						</div>
					</div>
				</section>
				<section>
					<h3 style="text-align: left">
						Addressing Anti-Patterns: Lessons from Established Companies</h3>
					<div class="fragment">
						<div class="typesetting">
						<p style="text-align: left">
							Even well-established companies encounter and overcome antipatterns,
							demonstrating resilience and the capacity for continuous improvement.</p>
						<ul>
							<li><strong class="important">Netflix's Transition:</strong>
								Originally faced challenges with the Monolithic Architecture anti-pattern. By adopting a microservices architecture, Netflix enhanced scalability and deployment speeds, showcasing the importance of architectural evolution
							</li>
							<li><strong class="important">Microsoft's GitHub Acquisition:</strong>
								Demonstrated a strategic move away from the Vendor Lock-in anti-pattern by embracing open source projects and community engagement, broadening their technology stack and innovation potential
							</li>
						</ul>
						<p style="text-align: left">
							These examples underline the significance of recognizing,
							addressing, and learning from anti-patterns to foster growth and
							innovation.</p>
						</div>
					</div>
				</section>
				<section>
				  <h3 style="text-align: left">Summary</h3>
					<div class="fragment">
						<div class="typesetting">
						  <ul>
							<li>Patterns as blueprints for robust design,
								categorized into Creational,
								Structural, Behavioral, and Concurrency</li>
							<li>Anti-Patterns identified as common pitfalls
								with strategies to refactor</li>
							<li>Case studies in open-source and enterprise-level applications
								underline their real-world significance</li>
						  </ul>
						</div>
					</div>
				</section>
			</section>
		</div>
	</div>
		<script src="../dist/reveal.js"></script>
		<script src="../plugin/notes/notes.js"></script>
		<script src="../plugin/markdown/markdown.js"></script>
		<script src="../plugin/highlight/highlight.js"></script>
		<script src="../plugin/math/math.js"></script>
		<script src="../scripts/utils.js"></script>
		<script>
			// More info about initialization & config:
			// - https://revealjs.com/initialization/
			// - https://revealjs.com/config/
			Reveal.initialize({
				hash: true,
				// The "normal" size of the presentation, aspect ratio will
				// be preserved when the presentation is scaled to fit different
				// resolutions. Can be specified using percentage units.
				width: '100%',
				height: '100%',
				// Factor of the display size that should remain empty around the content
				margin: 0.08,

				// Bounds for smallest/largest possible scale to apply to content
				minScale: 0.2,
				maxScale: 2.0,
				plugins: [ RevealMarkdown, RevealHighlight, RevealNotes, RevealMath.KaTeX ]
			});

			Reveal.addEventListener('fragmentshown', function (event) {
				if (lettersAnimate) {
					[...event.fragment.getElementsByClassName('typesetting')].forEach(element => {
						playAnimation(element);
					});
				}
			});

		</script>
    </body>
</html>
